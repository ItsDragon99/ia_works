{"instruction": "Explica qué es un algoritmo", "response": "Un algoritmo es un conjunto de instrucciones paso a paso para resolver un problema específico, como una receta de cocina para tareas computacionales."}
{"instruction": "¿Cuál es la diferencia entre O(n) y O(n²)?", "response": "O(n) crece linealmente con la entrada, mientras que O(n²) crece cuadráticamente. Para n=100, O(n) requiere ~100 operaciones, O(n²) requiere ~10,000."}
{"instruction": "Define 'estructura de datos'", "response": "Es una forma organizada de almacenar y gestionar datos para acceder y modificarlos eficientemente. Ejemplos: arreglos, listas, pilas, colas, árboles."}
{"instruction": "¿Qué hace un bucle 'for'?", "response": "Repite un bloque de código un número específico de veces. En Python: for i in range(5): print(i) imprimirá 0,1,2,3,4."}
{"instruction": "Muestra un ejemplo de función en pseudocódigo", "response": "FUNCIÓN sumar(a, b):     resultado ← a + b     DEVOLVER resultado FIN FUNCIÓN"}
{"instruction": "¿Qué es la recursión?", "response": "Es cuando una función se llama a sí misma para resolver subproblemas más pequeños. Debe tener un caso base para terminar."}
{"instruction": "Explica 'condicional if'", "response": "Ejecuta código solo si se cumple una condición. Ejemplo: if edad >= 18: print('Mayor') else: print('Menor')."}
{"instruction": "Define 'variable' en programación", "response": "Es un contenedor que almacena un valor que puede cambiar durante la ejecución del programa. Ejemplo: contador = 0."}
{"instruction": "¿Qué es un arreglo?", "response": "Colección ordenada de elementos del mismo tipo, accesibles por índice. En Java: int[] numeros = {1,2,3}; numeros[0] es 1."}
{"instruction": "Muestra un swap básico de variables", "response": "temp ← a a ← b b ← temp // Intercambia los valores de a y b usando una variable temporal."}
{"instruction": "Explica 'pila' (stack)", "response": "Estructura LIFO (último en entrar, primero en salir). Operaciones: push (añadir), pop (remover), peek (ver tope)."}
{"instruction": "¿Qué es una 'cola' (queue)?", "response": "Estructura FIFO (primero en entrar, primero en salir). Como una fila: enqueue (añadir al final), dequeue (remover del frente)."}
{"instruction": "Define 'lista enlazada'", "response": "Colección de nodos donde cada nodo contiene datos y un enlace al siguiente nodo. No requiere memoria contigua."}
{"instruction": "Muestra bucle while simple", "response": "i ← 0 MIENTRAS i < 5 HACER     imprimir(i)     i ← i + 1 FIN MIENTRAS"}
{"instruction": "Explica 'ordenamiento burbuja'", "response": "Compara pares adyacentes y los intercambia si están en orden incorrecto. Repite hasta que no haya intercambios."}
{"instruction": "¿Qué es 'búsqueda binaria'?", "response": "Algoritmo eficiente (O(log n)) para buscar en arreglos ordenados. Divide repetidamente el espacio de búsqueda a la mitad."}
{"instruction": "Define 'complejidad temporal'", "response": "Mide cómo crece el tiempo de ejecución con el tamaño de entrada. Se expresa con notación O grande (O, Ω, Θ)."}
{"instruction": "Explica 'divide y vencerás'", "response": "Estrategia que divide problemas en subproblemas más pequeños, los resuelve recursivamente y combina soluciones."}
{"instruction": "Muestra un nodo de árbol binario", "response": "struct Nodo {     int valor;     Nodo* izquierdo;     Nodo* derecho; } // Cada nodo tiene hasta dos hijos."}
{"instruction": "¿Qué es un grafo?", "response": "Conjunto de vértices conectados por aristas. Puede ser dirigido o no dirigido, ponderado o no ponderado."}
{"instruction": "Explica 'backtracking'", "response": "Técnica que prueba soluciones parciales, retrocede si no son válidas y explora alternativas. Usado en puzzles como N-Reinas."}
{"instruction": "Define 'tabla hash'", "response": "Estructura que asocia claves con valores usando función hash. Búsqueda promedio O(1). Ejemplo: diccionarios en Python."}
{"instruction": "Muestra recorrido inorder de árbol", "response": "1. Recorrer subárbol izquierdo 2. Visitar raíz 3. Recorrer subárbol derecho // Para BST, produce valores ordenados."}
{"instruction": "¿Qué es 'programación dinámica'?", "response": "Resuelve problemas complejos almacenando resultados de subproblemas (memoización) para evitar recálculos."}
{"instruction": "Explica 'Árbol de expansión mínima'", "response": "Subgrafo que conecta todos vértices con el mínimo peso total. Algoritmos: Prim y Kruskal."}
{"instruction": "Define 'recursión de cola'", "response": "Cuando la llamada recursiva es la última operación. Puede optimizarse a iterativo por el compilador."}
{"instruction": "Muestra inserción en lista enlazada", "response": "nuevoNodo.siguiente = anterior.siguiente anterior.siguiente = nuevoNodo // Inserta después del nodo 'anterior'."}
{"instruction": "¿Qué es 'Dijkstra'?", "response": "Algoritmo que encuentra caminos mínimos desde un origen en grafos con pesos no negativos."}
{"instruction": "Explica 'notación O grande'", "response": "Describe límite superior del crecimiento. O(n²) significa que en peor caso crece proporcional a n²."}
{"instruction": "Define 'montículo' (heap)", "response": "Árbol binario completo donde cada nodo es mayor/menor que sus hijos. Usado para colas de prioridad."}
{"instruction": "Muestra búsqueda lineal", "response": "PARA cada elemento en arreglo:     SI elemento == objetivo:         DEVOLVER índice DEVOLVER -1"}
{"instruction": "¿Qué es 'recorrido BFS'?", "response": "Búsqueda en anchura: explora nivel por nivel usando cola. Útil para caminos mínimos en grafos no ponderados."}
{"instruction": "Explica 'algoritmo voraz'", "response": "Toma decisiones localmente óptimas en cada paso, esperando obtener solución global óptima. Ejemplo: cambio con monedas."}
{"instruction": "Define 'árbol binario de búsqueda'", "response": "Árbol donde hijos izquierdos < padre < hijos derechos. Permite búsqueda eficiente O(log n) en caso balanceado."}
{"instruction": "Muestra función factorial recursiva", "response": "FUNCIÓN factorial(n):     SI n <= 1:         DEVOLVER 1     SINO:         DEVOLVER n * factorial(n-1)"}
{"instruction": "¿Qué es 'Topological Sort'?", "response": "Ordenamiento lineal de vértices donde si existe arista u→v, u aparece antes que v. Para grafos dirigidos acíclicos."}
{"instruction": "Explica 'memorización'", "response": "Guardar resultados de subproblemas en caché para reutilización. Clave en programación dinámica."}
{"instruction": "Define 'lista doblemente enlazada", "response": "Cada nodo tiene enlaces al siguiente y anterior. Permite recorrido en ambas direcciones."}
{"instruction": "Muestra algoritmo de Prim", "response": "1. Empezar con vértice arbitrario 2. Añadir arista mínima que conecte árbol con vértice nuevo 3. Repetir hasta incluir todos vértices"}
{"instruction": "¿Qué es 'recorrido DFS'?", "response": "Búsqueda en profundidad: explora hasta el fondo de cada rama antes de retroceder. Implementación natural recursiva."}
{"instruction": "Explica 'problema de mochila'", "response": "Maximizar valor de items en mochila con capacidad límite. Versión 0/1: item completo o nada. Dinámica O(nW)."}
{"instruction": "Define 'árbol AVL'", "response": "BST auto-balanceado donde alturas de subárboles difieren máximo 1. Rotaciones mantienen balance."}
{"instruction": "Muestra QuickSort paso a paso", "response": "1. Elegir pivote 2. Particionar: menores a izquierda, mayores a derecha 3. Ordenar recursivamente cada parte"}
{"instruction": "¿Qué es 'algoritmo de Kruskal'?", "response": "Para MST: ordenar aristas por peso, añadir aristas que no formen ciclo (usando Union-Find)."}
{"instruction": "Explica 'código de Huffman'", "response": "Compresión asignando códigos más cortos a caracteres frecuentes. Construye árbol de prefijos óptimo."}
{"instruction": "Define 'puntero'", "response": "Variable que almacena dirección de memoria de otra variable. Permite estructuras dinámicas y paso por referencia."}
{"instruction": "Muestra MergeSort conceptual", "response": "1. Dividir lista en mitades 2. Ordenar cada mitad recursivamente 3. Combinar mitades ordenadas // Complejidad O(n log n)"}
{"instruction": "¿Qué es 'Bellman-Ford'?", "response": "Encuentra caminos mínimos con pesos negativos (sin ciclos negativos). Más lento que Dijkstra O(VE)."}
{"instruction": "Explica 'problema de viajante'", "response": "Encontrar ruta más corta que visite todas ciudades exactamente una vez. NP-Completo."}
{"instruction": "Define 'cola de prioridad'", "response": "Estructura donde elemento con mayor/menor prioridad sale primero. Implementada con montículo."}
{"instruction": "Muestra operación push en pila", "response": "SI tope < capacidad:     tope ← tope + 1     pila[tope] ← valor SINO: error 'Desbordamiento'"}
{"instruction": "¿Qué es 'inorden, preorden, postorden'?", "response": "Formas de recorrer árboles: - Preorden: raíz, izquierdo, derecho - Inorden: izquierdo, raíz, derecho - Postorden: izquierdo, derecho, raíz"}
{"instruction": "Explica 'programación orientada a objetos'", "response": "Paradigma basado en objetos (instancias de clases) que encapsulan datos y comportamientos relacionados."}
{"instruction": "Define 'algoritmo de Floyd-Warshall'", "response": "Encuentra caminos mínimos entre todos pares de vértices O(V³). Usa programación dinámica."}
{"instruction": "Muestra búsqueda en BST", "response": "FUNCIÓN buscar(raíz, clave):     SI raíz es NULO O raíz.clave == clave:         DEVOLVER raíz     SI clave < raíz.clave:         DEVOLVER buscar(raíz.izquierdo, clave)     SINO:         DEVOLVER buscar(raíz.derecho, clave)"}
{"instruction": "¿Qué es 'corte mínimo en grafo'?", "response": "Conjunto mínimo de aristas que al remover desconectan el grafo. Relacionado con flujo máximo (teorema max-flow min-cut)."}
{"instruction": "Explica 'algoritmo de Euclides'", "response": "Encuentra máximo común divisor: MCD(a,b)=MCD(b, a mod b). Iterativo hasta que b=0."}
{"instruction": "Define 'función de hash'", "response": "Convierte clave de tamaño variable a valor fijo (índice). Idealmente uniforme para minimizar colisiones."}
{"instruction": "Muestra selección directa (selection sort)", "response": "PARA i de 0 a n-2:     min_idx ← i     PARA j de i+1 a n-1:         SI arreglo[j] < arreglo[min_idx]:             min_idx ← j     intercambiar(arreglo[i], arreglo[min_idx])"}
{"instruction": "¿Qué es 'NP-Completo'?", "response": "Clase de problemas decisión: verificable en tiempo polinomial, pero no se sabe si resolubles en tiempo polinomial."}
{"instruction": "Explica 'árbol rojo-negro'", "response": "BST balanceado con nodos rojos/negros y reglas que garantizan altura O(log n). Más flexible que AVL."}
{"instruction": "Define 'lista circular", "response": "Lista donde último nodo apunta al primero. Útil para buffers y programación round-robin."}
{"instruction": "Muestra operación dequeue en cola", "response": "SI frente <= final:     valor ← cola[frente]     frente ← frente + 1     DEVOLVER valor SINO: error 'Cola vacía'"}
{"instruction": "¿Qué es 'algoritmo de Rabin-Karp'?", "response": "Búsqueda de patrones usando hashing. Compara hash del patrón con hash de subcadenas. O(n+m) promedio."}
{"instruction": "Explica 'problema de subconjunto suma'", "response": "Dado conjunto, ¿existe subconjunto que sume objetivo? NP-Completo, resoluble con programación dinámica pseudo-polinomial."}
{"instruction": "Define 'matriz de adyacencia'", "response": "Representación gráfica: matriz N×N donde celda[i][j]=1 si existe arista i→j. O(1) para verificar arista, O(V²) espacio."}
{"instruction": "Muestra inserción en árbol AVL", "response": "1. Insertar como BST normal 2. Actualizar altura de ancestros 3. Rebalancear si factor balance >1: rotaciones simple/doble"}
{"instruction": "¿Qué es 'algoritmo A*'?", "response": "Búsqueda heurística que combina costo real g(n) y estimado h(n). f(n)=g(n)+h(n). Óptimo si h(n) es admisible."}
{"instruction": "Explica 'código Gray'", "response": "Secuencia donde números consecutivos difieren en un bit. Usado en codificadores y evitar errores de transición."}
{"instruction": "Define 'montículo binomial'", "response": "Colección de árboles binomiales que satisfacen propiedad de montículo. Operaciones unión eficiente O(log n)."}
{"instruction": "Muestra algoritmo de KMP para strings", "response": "1. Preprocesar patrón para crear tabla LPS (prefijo-sufijo más largo) 2. Buscar con saltos inteligentes evitando comparaciones innecesarias"}
{"instruction": "¿Qué es 'problema de coloración de grafos'?", "response": "Asignar colores a vértices adyacentes diferentes. Número cromático mínimo es NP-difícil."}
{"instruction": "Explica 'algoritmo de Ford-Fulkerson'", "response": "Encuentra flujo máximo en red residual. Añade flujo mientras exista camino aumentante."}
{"instruction": "Define 'árbol de segmentos'", "response": "Estructura para consultas de rango y actualizaciones en arreglos. Construcción O(n), consulta O(log n)."}
{"instruction": "Muestra eliminación en lista enlazada", "response": "anterior.siguiente = actual.siguiente liberar(actual) // Elimina nodo 'actual' cuando 'anterior' apunta a él"}
{"instruction": "¿Qué es 'algoritmo de Warshall'?", "response": "Versión de Floyd-Warshall para cierre transitivo (conexión) en grafos dirigidos. Transforma matriz adyacencia."}
{"instruction": "Explica 'problema de la mochila fraccional'", "response": "Versión donde se pueden tomar fracciones de items. Solución voraz: ordenar por valor/peso y tomar fracciones."}
{"instruction": "Define 'hash abierto vs cerrado'", "response": "Abierto: colisiones resueltas con listas. Cerrado: busca otra celda (sondeo). Abierto maneja mejor factor carga alto."}
{"instruction": "Muestra rotación derecha en AVL", "response": "y = x.izquierdo x.izquierdo = y.derecho y.derecho = x actualizarAlturas(x,y) raíz = y"}
{"instruction": "¿Qué es 'algoritmo de Kosaraju'?", "response": "Encuentra componentes fuertemente conexos en grafos dirigidos O(V+E). Dos DFS: grafo original y transpuesto."}
{"instruction": "Explica 'problema de la cubierta de vértices'", "response": "Conjunto mínimo de vértices que toca todas aristas. NP-Completo. Aproximación 2-optima: emparejamiento máximo."}
{"instruction": "Define 'árbol B'", "response": "Árbol balanceado donde cada nodo puede tener muchos hijos. Optimizado para discos (bloques). Usado en bases de datos."}
{"instruction": "Muestra operación peek en pila", "response": "SI tope >= 0:     DEVOLVER pila[tope] SINO: error 'Pila vacía' // Observa elemento superior sin remover"}
{"instruction": "¿Qué es 'algoritmo de Edmonds-Karp'?", "response": "Implementación Ford-Fulkerson con BFS para camino aumentante. Garantiza O(VE²) y evita problemas con pesos irracionales."}
{"instruction": "Explica 'problema de la subsecuencia común más larga'", "response": "Encontrar subsecuencia más larga presente en dos strings. Programación dinámica O(mn)."}
{"instruction": "Define 'montículo de Fibonacci'", "response": "Estructura amortizada eficiente para colas prioridad. Operación disminuir clave O(1) amortizado."}
{"instruction": "Muestra DFS iterativo con pila", "response": "apilar(raíz) MIENTRAS pila no vacía:     v = desapilar()     marcar v visitado     PARA cada adyacente u de v:         SI u no visitado: apilar(u)"}
{"instruction": "¿Qué es 'algoritmo de Manacher'?", "response": "Encuentra palíndromos más largos en O(n). Usa simetría para evitar recálculos."}
{"instruction": "Explica 'problema del flujo máximo'", "response": "Maximizar flujo de fuente a sumidero en red con capacidades. Algoritmos: Ford-Fulkerson, Dinic, Edmonds-Karp."}
{"instruction": "Define 'árbol 2-3'", "response": "Árbol balanceado donde nodos tienen 2-3 hijos y 1-2 claves. Todos hojas misma profundidad."}
{"instruction": "Muestra algoritmo de Dijsktra paso a paso", "response": "1. Inicializar distancias: origen=0, otros=∞ 2. Mientras cola prioridad no vacía:    - Extraer vértice u mínimo    - Para cada vecino v: relajar arista u-v"}
{"instruction": "¿Qué es 'algoritmo de Dinic'?", "response": "Para flujo máximo O(V²E). Usa BFS para niveles y DFS bloqueante para flujo."}
{"instruction": "Explica 'problema de la mochila 0/1' con PD", "response": "dp[i][w] = máximo valor con i items y capacidad w. dp[i][w]=max(dp[i-1][w], val[i]+dp[i-1][w-peso[i]])."}
{"instruction": "Define 'skip list'", "response": "Estructura probabilística con múltiples niveles de listas enlazadas. Búsqueda O(log n) esperado, alternativa a árboles."}
{"instruction": "Muestra BFS con cola", "response": "encolar(raíz) raíz.visitado = verdadero MIENTRAS cola no vacía:     v = desencolar()     PROCESAR v     PARA cada adyacente u:         SI no visitado: encolar(u), marcar visitado"}
{"instruction": "¿Qué es 'algoritmo de Karatsuba'?", "response": "Multiplicación rápida O(n^1.585). Divide números en mitades: (a+b)(c+d)-ac-bd = ad+bc."}
{"instruction": "Explica 'problema del agente viajero' con heurísticas", "response": "Heurísticas: vecino más cercano, inserción, 2-opt. No garantizan óptimo pero dan soluciones razonables rápido."}
{"instruction": "Define 'trie'", "response": "Árbol para strings donde cada nodo representa prefijo. Búsqueda O(L) para string longitud L. Usado en autocompletado."}
{"instruction": "Muestra Merge paso a paso", "response": "i←inicio, j←medio+1, k←0 MIENTRAS i<=medio Y j<=fin:     SI arr[i]<=arr[j]: temp[k++]←arr[i++]     SINO: temp[k++]←arr[j++] COPIAR elementos restantes"}
{"instruction": "¿Qué es 'algoritmo de Strassen'?", "response": "Multiplicación matricial O(n^2.807). Divide matrices, usa 7 multiplicaciones en lugar de 8 para submatrices."}
{"instruction": "Explica 'problema de la subsecuencia creciente más larga'", "response": "Encontrar subsecuencia creciente más larga. PD O(n²) o con búsqueda binaria O(n log n)."}
{"instruction": "Define 'árbol de Fenwick'", "response": "Estructura para sumas prefijo y actualizaciones O(log n). Más simple que árbol segmentos para operaciones acumulativas."}
{"instruction": "Muestra Heapify abajo-arriba", "response": "PARA i = tamaño/2 HASTA 0:     hundir(i) // Construye montículo en O(n)"}
{"instruction": "¿Qué es 'algoritmo de Boyer-Moore'?", "response": "Búsqueda de patrones que compara de derecha a izquierda, permite saltos grandes. Bueno para texto natural."}
{"instruction": "Explica 'problema de partición'", "response": "¿Se puede dividir conjunto en dos subconjuntos con igual suma? NP-Completo. PD similar a mochila."}
{"instruction": "Define 'árbol de sufijos'", "response": "Árbol comprimido de todos sufijos de string. Permite búsqueda substring O(m). Construcción O(n)."}
{"instruction": "Muestra QuickSelect para k-ésimo menor", "response": "1. Particionar como QuickSort 2. Si índice pivote == k: devolver elemento 3. Si k < índice: buscar en izquierda 4. Si k > índice: buscar en derecha"}
{"instruction": "¿Qué es 'algoritmo de Hopcroft-Karp'?", "response": "Encuentra máximo emparejamiento en grafo bipartito O(E√V). Usa BFS para caminos aumentantes."}
{"instruction": "Explica 'problema de la mochila ilimitada'", "response": "Versión donde items pueden tomarse múltiples veces. PD similar pero iterar capacidad ascendente."}
{"instruction": "Define 'algoritmo online vs offline'", "response": "Online procesa entrada secuencialmente sin ver futuro. Offline conoce toda entrada de antemano. Ejemplo: paginación."}
{"instruction": "Muestra algoritmo de inserción directa", "response": "PARA i de 1 a n-1:     clave = arreglo[i]     j = i-1     MIENTRAS j>=0 Y arreglo[j]>clave:         arreglo[j+1]=arreglo[j]         j=j-1     arreglo[j+1]=clave"}
{"instruction": "¿Qué es 'algoritmo de Tarjan'?", "response": "Encuentra componentes fuertemente conexos con un solo DFS. Usa números de descubrimiento y low-link."}
{"instruction": "Explica 'problema de la planificación de tareas'", "response": "Asignar tareas a máquinas minimizando makespan. NP-difícil. Heurística: LPT (Longest Processing Time first)."}
{"instruction": "Define 'cuckoo hashing'", "response": "Esquema hash con dos tablas y funciones. Si colisión, reubica elementos existentes. Búsqueda O(1) en peor caso."}
{"instruction": "Muestra recorrido postorden iterativo", "response": "Usar dos pilas: 1. Apilar raíz en pila1 2. Mientras pila1 no vacía:    - v = desapilar pila1    - apilar v en pila2    - apilar hijos izquierdo/derecho en pila1 3. Procesar pila2"}
{"instruction": "¿Qué es 'algoritmo de Bellman-Ford vs Dijkstra'?", "response": "Dijkstra más rápido O(E+VlogV) pero no pesos negativos. Bellman-Ford O(VE) pero detecta ciclos negativos."}
{"instruction": "Explica 'problema del cambio de monedas'", "response": "Mínimo número de monedas para formar cantidad. Voraz óptimo para denominaciones canónicas (1,5,10...). PD general."}
{"instruction": "Define 'árbol de intervalos'", "response": "Estructura para intervalos, permite encontrar todos intervalos que contienen punto. BST con intervalos como claves."}
{"instruction": "Muestra Bucket Sort conceptual", "response": "1. Crear n cubetas 2. Distribuir elementos en cubetas 3. Ordenar cada cubeta 4. Concatenar cubetas // Bueno para datos distribuidos uniformemente"}
{"instruction": "¿Qué es 'algoritmo de Christofides'?", "response": "Aproximación 1.5-optima para TSP métrico (triángulo desigualdad). Combina MST y emparejamiento mínimo."}
{"instruction": "Explica 'problema de la mochila multidimensional'", "response": "Múltiples restricciones (peso, volumen). PD con más dimensiones. Variables: dp[i][w1][w2]..."}
{"instruction": "Define 'counting sort'", "response": "Ordenamiento no comparativo para enteros en rango conocido. Cuenta ocurrencias, luego reconstruye. O(n+k) donde k es rango."}
{"instruction": "Muestra algoritmo de Prim con montículo", "response": "1. Inicializar montículo min con vértice origen (distancia 0) 2. Mientras montículo no vacío:    - Extraer u    - Para cada vecino v: si peso(u,v) < dist[v], actualizar y añadir a montículo"}
{"instruction": "¿Qué es 'algoritmo de Needleman-Wunsch'?", "response": "Alineamiento global de secuencias usando programación dinámica. Maximiza puntaje de coincidencias/descartes/brechas."}
{"instruction": "Explica 'problema de la mochila acoplada'", "response": "Items con dependencias (si tomas A, debes tomar B). Modelar con grafos o restricciones adicionales en PD."}
{"instruction": "Define 'Radix Sort LSD'", "response": "Ordena por dígitos menos significativos primero. Usa Counting Sort estable para cada dígito. O(d(n+k))."}
{"instruction": "Muestra eliminación en BST", "response": "Caso 1: Sin hijos → eliminar directo Caso 2: Un hijo → reemplazar con hijo Caso 3: Dos hijos → encontrar sucesor inorden, copiar valor, eliminar sucesor"}
{"instruction": "¿Qué es 'algoritmo de Levenshtein'?", "response": "Distancia de edición mínima entre strings (inserciones, eliminaciones, sustituciones). PD clásica O(mn)."}
{"instruction": "Explica 'problema de la mochila con múltiples mochilas'", "response": "Variante bin packing: distribuir items en múltiples contenedores minimizando contenedores usados. NP-difícil."}
{"instruction": "Define 'Shell sort'", "response": "Generalización Insertion Sort con brechas decrecientes. Mejora tiempos prácticos. Brecha secuencia: Knuth (3^k-1)/2."}
{"instruction": "Muestra Floyd-Warshall paso a paso", "response": "dist = matriz adyacencia PARA k de 0 a V-1:     PARA i de 0 a V-1:         PARA j de 0 a V-1:             dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j])"}
{"instruction": "¿Qué es 'algoritmo de Smith-Waterman'?", "response": "Alineamiento local de secuencias. Similar Needleman-Wunsch pero permite comenzar/terminar en cualquier punto."}
{"instruction": "Explica 'problema de la subsecuencia común máxima con k cambios'", "response": "Permite hasta k modificaciones. PD extendida: dp[i][j][k] = LCS considerando cambios."}
{"instruction": "Define 'comb sort'", "response": "Mejora Bubble Sort con brecha inicial grande que se reduce por factor 1.3. Elimina tortugas (elementos pequeños al final)."}
{"instruction": "Muestra operación union en disjoint-set", "response": "FUNCIÓN union(x, y):     raízX = find(x)     raízY = find(y)     SI raízX != raízY:         SI rango[raízX] < rango[raízY]: padre[raízX]=raízY         SINO SI rango[raízX]>rango[raízY]: padre[raízY]=raízX         SINO: padre[raízY]=raízX, rango[raízX]++"}
{"instruction": "¿Qué es 'algoritmo de Viterbi'?", "response": "Encuentra secuencia más probable de estados ocultos en HMM (Modelo Oculto de Markov). Programación dinámica."}
{"instruction": "Explica 'problema de la mochila con límite de items'", "response": "Máximo m items. PD extendida: dp[i][w][c] con c contador de items."}
{"instruction": "Define 'gnome sort'", "response": "Similar Insertion Sort pero intercambiando hacia atrás como burbuja. Nombrado por gnomo de jardín que ordena macetas."}
{"instruction": "Muestra algoritmo de Kruskal con Union-Find", "response": "1. Ordenar aristas por peso ascendente 2. Inicializar disjoint-set 3. Para cada arista (u,v,w):    - si find(u) != find(v): añadir a MST, union(u,v)"}
{"instruction": "¿Qué es 'algoritmo de Baum-Welch'?", "response": "Aprende parámetros de HMM (transición, emisión) dado secuencia observada. Usa Expectación-Maximización."}
{"instruction": "Explica 'problema de la mochila con beneficios estocásticos'", "response": "Valores o pesos aleatorios. Optimizar valor esperado. Resoluble con PD estocástica o programación dinámica robusta."}
{"instruction": "Define 'stooge sort'", "response": "Algoritmo recursivo ineficiente O(n^2.7). Más lento que burbuja. Ordena primeros 2/3, últimos 2/3, primeros 2/3 otra vez."}
{"instruction": "Muestra algoritmo de Dinic con niveles", "response": "1. BFS para asignar niveles 2. DFS bloqueante para enviar flujo 3. Repetir hasta que BFS no alcance sumidero"}
{"instruction": "¿Qué es 'algoritmo de Forward-Backward'?", "response": "Calcula probabilidades de estados en HMM dado observaciones. Paso forward (α) y backward (β)."}
{"instruction": "Explica 'problema de la mochila con items divisibles e indivisibles'", "response": "Mezcla: algunos items fraccionables, otros no. Voraz para fraccionables, PD para indivisibles, combinación compleja."}
{"instruction": "Define 'bogosort'", "response": "Algoritmo jocoso: permutar aleatoriamente hasta que esté ordenado. O((n+1)!) promedio. Solo para demostración humorística."}
{"instruction": "Muestra algoritmo de Edmonds-Karp paso a paso", "response": "1. Inicializar flujo 0 2. Mientras exista camino aumentante (BFS):    - Encontrar capacidad mínima en camino    - Aumentar flujo a lo largo del camino    - Actualizar red residual"}
{"instruction": "¿Qué es 'algoritmo de Expectación-Maximización'?", "response": "Itera entre E-step (calcular expectativas) y M-step (maximizar parámetros). Para modelos con variables latentes."}
{"instruction": "Explica 'problema de la mochila con restricciones de contigüidad'", "response": "Items deben tomarse en bloques contiguos. PD 2D: dp[i][j] = máximo valor tomando items i..j."}
{"instruction": "Define 'sleep sort'", "response": "Juego: por cada elemento x, crear hilo que duerme x segundos luego imprime x. 'Funciona' pero no es serio."}
{"instruction": "Muestra algoritmo de Hopcroft-Karp básico", "response": "1. Emparejamiento vacío 2. Mientras existan caminos aumentantes (BFS desde vértices libres):    - DFS para encontrar caminos disjuntos    - Aumentar emparejamiento"}
{"instruction": "¿Qué es 'algoritmo de k-means'?", "response": "Agrupamiento no supervisado. Asigna puntos a k centroides, recalcula centroides, repite hasta convergencia."}
{"instruction": "Explica 'problema de la mochila con items interdependientes'", "response": "Utilidad conjunta de items (sinérgica o antagónica). Modelar con programación cuadrática o árbol de decisiones."}
{"instruction": "Define 'pancake sort'", "response": "Ordena con operación 'voltear prefijo'. Problema: mínimo número de volteos. Interesante teóricamente, poco práctico."}
{"instruction": "Muestra algoritmo de Kosaraju paso a paso", "response": "1. DFS en grafo original, guardar orden de finalización 2. Transponer grafo (invertir aristas) 3. DFS en orden inverso de finalización, cada DFS es un CFC"}
{"instruction": "¿Qué es 'algoritmo de Lloyd'?", "response": "Otro nombre para k-means. Atribuido a Lloyd (1957) pero publicado más tarde."}
{"instruction": "Explica 'problema de la mochila con tiempo'", "response": "Items disponibles en ventanas temporales. PD con dimensión tiempo además de capacidad."}
{"instruction": "Define 'bitonic sort'", "response": "Algoritmo paralelo para arquitecturas SIMD. Crea secuencia bitónica luego la ordena. O(log² n) paralelo."}
{"instruction": "Muestra algoritmo de Manacher para palíndromos", "response": "1. Transformar string con separadores (#a#b#a#) 2. Array P para radios 3. Usar simetría para llenar P[i] 4. Expandir cuando necesario"}
{"instruction": "¿Qué es 'algoritmo DBSCAN'?", "response": "Agrupamiento por densidad. Puntos núcleo, borde y ruido. Encuentra clusters arbitrarios, robusto a outliers."}
{"instruction": "Explica 'problema de la mochila con capacidad variable'", "response": "Capacidad cambia con tiempo o por items tomados. Modelar como problema de control óptimo o PD con estado complejo."}
{"instruction": "Define 'cocktail shaker sort'", "response": "Burbuja bidireccional. Pasa izquierda-derecha luego derecha-izquierda. Elimina algunas tortugas y liebres."}
{"instruction": "Muestra algoritmo de Strassen para matrices 2x2", "response": "M1 = (A11+A22)*(B11+B22) M2 = (A21+A22)*B11 M3 = A11*(B12-B22) M4 = A22*(B21-B11) M5 = (A11+A12)*B22 M6 = (A21-A11)*(B11+B12) M7 = (A12-A22)*(B21+B22) C11 = M1+M4-M5+M7 C12 = M3+M5 C21 = M2+M4 C22 = M1-M2+M3+M6"}
{"instruction": "¿Qué es 'algoritmo OPTICS'?", "response": "Extensión DBSCAN que produce ordenamiento de densidad, permitiendo clusters a diferentes umbrales."}
{"instruction": "Explica 'problema de la mochila con descuentos por cantidad'", "response": "El valor por item cambia según cuántos tomas. PD con función valor no lineal."}
{"instruction": "Define 'odd-even sort'", "response": "Algoritmo paralelo comparativo. Fases impares (comparar pares 1-2,3-4...) y pares (2-3,4-5...). Para hardware paralelo."}
{"instruction": "Muestra algoritmo de Karatsuba para 1234*5678", "response": "a=12, b=34, c=56, d=78 ac = 12*56 = 672 bd = 34*78 = 2652 (a+b)(c+d)=46*134=6164 ad+bc = 6164-ac-bd = 6164-672-2652=2840 Resultado: ac*10000 + (ad+bc)*100 + bd = 6720000 + 284000 + 2652 = 7,006,652"}
{"instruction": "¿Qué es 'algoritmo de agrupamiento jerárquico'", "response": "Construye árbol de clusters (dendrograma). Enfoques: aglomerativo (abajo-arriba) o divisivo (arriba-abajo)."}
{"instruction": "Explica 'problema de la mochila con riesgo'", "response": "Items tienen riesgo asociado, límite de riesgo total. Multi-objetivo: maximizar valor, minimizar riesgo."}
{"instruction": "Define 'tim sort'", "response": "Híbrido Merge + Insertion usado en Python/Java. Encuentra 'runs' ordenados naturalmente, los fusiona inteligentemente."}
{"instruction": "Muestra algoritmo de Boyer-Moore mal carácter", "response": "Tabla de último ocurrencia por carácter en patrón. Al desalinear, saltar según: max(1, j - último[texto[i+j]])"}
{"instruction": "¿Qué es 'algoritmo de agrupamiento espectral'?", "response": "Usa autovectores de matriz Laplaciana del grafo de similitud. Captura estructura no convexa."}
{"instruction": "Explica 'problema de la mochila con múltiples objetivos'", "response": "Optimizar varios valores simultáneamente (valor, peso, tamaño). Soluciones Pareto-óptimas, frente de Pareto."}
{"instruction": "Define 'patience sorting'", "response": "Ordenamiento que simula juego de solitario. También encuentra subsecuencia creciente más larga. O(n log n)."}
{"instruction": "Muestra algoritmo de Rabin-Karp con hash simple", "response": "hash_patrón = Σ pat[i]*p^i mod m hash_ventana = Σ text[i]*p^i mod m Deslizar ventana: hash_nuevo = (hash_antiguo - text[i])/p + text[i+n]*p^(n-1)"}
{"instruction": "¿Qué es 'algoritmo de Birch'?", "response": "Agrupamiento jerárquico para grandes datasets. Usa árbol CF (Característica de Clustering) para resumir datos."}
{"instruction": "Explica 'problema de la mochila con items rotos'", "response": "Algunos items pueden estar dañados (valor reducido). Estado adicional en PD: calidad del item."}
{"instruction": "Define 'smoothsort'", "response": "Adaptación heapsort con complejidad O(n) para datos casi ordenados. Montículos de Leonardo. Complicado de implementar."}
{"instruction": "Muestra algoritmo de Tarjan para CFC", "response": "index = 0 pila vacía DFS(u):   low[u]=index[u]=++index   apilar u, enPila[u]=true   para cada vecino v:     si no visitado: DFS(v); low[u]=min(low[u],low[v])     si enPila[v]: low[u]=min(low[u],index[v])   si low[u]==index[u]: // raíz CFC     repetir: v=desapilar, enPila[v]=false hasta u==v"}
{"instruction": "¿Qué es 'algoritmo de Mean-Shift'?", "response": "Encuentra modos de densidad. Mueve ventana hacia región mayor densidad iterativamente. No requiere especificar k."}
{"instruction": "Explica 'problema de la mochila con aprendizaje'", "response": "Valores desconocidos, se aprenden tomando items. Problema bandido multi-brazo con restricción capacidad."}
{"instruction": "Define 'tournament sort'", "response": "Usa árbol de torneo. Primero construye árbol para encontrar máximo (O(n)), luego reemplaza y reajusta (O(log n))."}
{"instruction": "Muestra algoritmo de Christofides para TSP", "response": "1. Encontrar MST T 2. Encontrar conjunto M de vértices grado impar en T 3. Encontrar emparejamiento mínimo perfecto en M 4. Combinar T+M (grafo Euleriano) 5. Encontrar circuito Euleriano, convertirlo a Hamiltoniano (saltar repetidos)"}
{"instruction": "¿Qué es 'algoritmo de agrupamiento por difusión'?", "response": "Basado en dinámica de difusión en grafo. Captura estructura multiescala. Usa walktrap o similar."}
{"instruction": "Explica 'problema de la mochila con incertidumbre robusta'", "response": "Valores/ pesos en intervalos, optimizar peor caso. Programación robusta con restricciones de robustez."}
{"instruction": "Define 'cube sort'", "response": "Para paralelo, divide datos en cubos, ordena cubos independientemente, luego fusiona. Paralelización natural."}
{"instruction": "Muestra algoritmo de Needleman-Wunsch paso a paso", "response": "1. Matriz score: gap penalty, match reward, mismatch penalty 2. Llenar: F[i][j]=max(F[i-1][j-1]+s(xi,yj), F[i-1][j]+g, F[i][j-1]+g) 3. Traceback desde F[m][n]"}
{"instruction": "¿Qué es 'algoritmo de Louvain'?", "response": "Detecta comunidades en redes grandes. Maximiza modularidad. Dos fases: mover nodos entre comunidades, agrupar comunidades."}
{"instruction": "Explica 'problema de la mochila con capacidad estocástica'", "response": "Capacidad aleatoria. Optimizar valor esperado o satisfacer restricción con probabilidad mínima."}
{"instruction": "Define 'spaghetti sort'", "response": "Metáfora: cortar espaguetis proporcionales a valores, agarrar conjunto, tocar mesa para encontrar más corto. Físico, no digital."}
{"instruction": "Muestra algoritmo de Dijkstra con Fibonacci heap", "response": "1. Inicializar dist[origen]=0, otros=∞ 2. Insertar todos vértices en Fibonacci heap 3. Mientras heap no vacío:    - u = extract-min (O(log V))    - Para cada vecino v: si dist[u]+peso(u,v) < dist[v]:        decrease-key(v, nuevaDist) (O(1) amortizado)"}
{"instruction": "¿Qué es 'algoritmo de Gomory-Hu'?", "response": "Construye árbol de cortes mínimos para todos pares en grafo no dirigido. Resuelve V-1 problemas flujo máximo."}
{"instruction": "Explica 'problema de la mochila con tiempo de preparación'", "response": "Items requieren tiempo setup antes de poder tomarse. Modelar con restricciones de precedencia y tiempos."}
{"instruction": "Define 'network flow with lower bounds'", "response": "Flujo con cotas mínimas en aristas. Transformar: f'(e)=f(e)-l(e), ajustar capacidades y balances de nodos."}
{"instruction": "Muestra algoritmo de Huffman paso a paso", "response": "1. Crear nodo hoja por carácter con frecuencia 2. Mientras >1 nodo en cola prioridad:    - Extraer dos menores frecuencias    - Crear nodo interno con suma frecuencias    - Insertar en cola 3. Raíz es código Huffman"}
{"instruction": "¿Qué es 'algoritmo de Stoer-Wagner'?", "response": "Encuentra corte mínimo en grafo no dirigido. Contrae aristas iterativamente. O(VE + V² log V)."}
{"instruction": "Explica 'problema de la mochila con restricciones de cardinalidad'", "response": "Límite en número de items seleccionados. PD: dp[i][w][k] = máximo valor con i items, capacidad w, k items tomados."}
{"instruction": "Define 'árbol de búsqueda digital (DST)'", "response": "Similar trie pero almacena claves en nodos internos, no solo hojas. Más espacio eficiente para claves largas."}
{"instruction": "Muestra algoritmo de Ford-Fulkerson con DFS", "response": "flujo = 0 mientras exista camino aumentante (DFS):     flujo_aumento = mín capacidad residual en camino     aumentar flujo a lo largo camino     flujo += flujo_aumento"}
{"instruction": "¿Qué es 'algoritmo de Dinic con scaling'?", "response": "Mejora Dinic procesando capacidades en orden bits más significativos primero. O(E√(V) log C) para capacidades enteras."}
{"instruction": "Explica 'problema de la mochila con múltiples copias limitadas'", "response": "Cada item tiene límite máximo de copias c_i. PD extendida: considerar cada copia como pseudo-item o usar DP de mochila acotada."}
{"instruction": "Define 'árbol de rangos (range tree)'", "response": "Estructura para consultas ortogonales en d-dimensiones. Árbol primario para x, árboles secundarios para y. O(log^d n) query."}
{"instruction": "Muestra algoritmo de KMP con tabla LPS", "response": "long = 0; i = 1 lps[0] = 0 while i < m:     if pat[i] == pat[long]: long++; lps[i]=long; i++     else: if long!=0: long=lps[long-1]; else: lps[i]=0; i++"}
{"instruction": "¿Qué es 'algoritmo de Gabow'?", "response": "Para caminos mínimos con pesos negativos. Similar Johnson pero usa reweighting diferente. O(E + V log V) con Fibonacci heap."}
{"instruction": "Explica 'problema de la mochila con ventana deslizante'", "response": "Items expiran después de tiempo. Solo puedes tomar items en ventana temporal actual. PD con deque o estructura ventana."}
{"instruction": "Define 'árbol de segmentos persistente'", "response": "Versión inmutable que mantiene todas versiones anteriores. Útil para consultas en versiones históricas. O(log n) por versión."}
{"instruction": "Muestra algoritmo de Johnson para pesos negativos", "response": "1. Añadir nodo artificial con aristas peso 0 a todos 2. Bellman-Ford desde nodo artificial 3. Re-ponderar aristas: w'(u,v)=w(u,v)+h(u)-h(v) 4. Dijkstra desde cada vértice con pesos no negativos"}
{"instruction": "¿Qué es 'algoritmo de Madry'?", "response": "Para flujo máximo en grafos no dirigidos. Basado en rutas eléctricas y teoría Laplaciana. O(m^{10/7}) aproximadamente."}
{"instruction": "Explica 'problema de la mochila con convexidad'", "response": "Cuando función valor es cóncava en peso. Permite optimización más eficiente usando propiedades convexas."}
{"instruction": "Define 'árbol de Fenwick 2D'", "response": "Extensión a matrices. Suma submatriz y actualizaciones en O(log n log m). Menos general que árbol segmentos 2D pero más simple."}
{"instruction": "Muestra algoritmo de Stoer-Wagner paso a paso", "response": "min_cut = ∞ while |V| > 1:     ejecutar fase Maximum Adjacency Ordering     cortar último vértice agregado     min_cut = min(min_cut, corte)     contraer últimos dos vértices"}
{"instruction": "¿Qué es 'algoritmo de Push-Relabel'?", "response": "Para flujo máximo. Mantiene preflujo, empuja exceso a vecinos, relabela altura cuando necesario. O(V²√E) o O(V³)."}
{"instruction": "Explica 'problema de la mochila con función valor no aditiva'", "response": "Valor total no es suma de valores individuales. PD requiere evaluar función completa, exponencial en peor caso."}
{"instruction": "Define 'Skip graph'", "response": "Estructura distribuida peer-to-peer que generaliza skip list a red. Mantiene conectividad y permite búsqueda O(log n)."}
{"instruction": "Muestra algoritmo de Gomory-Hu iterativo", "response": "1. Inicializar árbol con un vértice 2. Para i=2 to n:    - Elegir s=i, t=padre(s) en árbol actual    - Calcular corte mínimo entre s-t    - Actualizar árbol con nuevo corte"}
{"instruction": "¿Qué es 'algoritmo de Orlin'?", "response": "Flujo máximo en O(VE). Mejor teórico para grafos densos. Usa escalado y árboles dinámicos."}
{"instruction": "Explica 'problema de la mochila con aversión al riesgo'", "response": "Maximizar utilidad esperada bajo función utilidad cóncava (ej: logarítmica). Incorporar aversión riesgo en función objetivo."}
{"instruction": "Define 'Cuckoo Graph'", "response": "Grafo bipartito donde lados conectan ubicaciones posibles de cada elemento en cuckoo hashing. Ciclos causan problemas."}
{"instruction": "Muestra algoritmo de Tarjan para puentes", "response": "DFS manteniendo tin[u] (tiempo entrada) y low[u] low[u]=min(tin[u], low[v] para hijos, tin[w] para back edges) Si low[v] > tin[u] entonces (u,v) es puente"}
{"instruction": "¿Qué es 'algoritmo de Goldberg-Rao'?", "response": "Flujo máximo O(min(V^{2/3}, E^{1/2}) * E log(V²/E) log U). Usa blocking flow con escalado de capacidades."}
{"instruction": "Explica 'problema de la mochila con correlación entre items'", "response": "Items correlacionados (positiva/negativamente). Utilidad conjunta modelada con covarianza. Formulación cuadrática compleja."}
{"instruction": "Define 'Bloomier filter'", "response": "Estructura probabilística que asocia valor con clave (no solo membresía). Extensión Bloom filter para funciones aproximadas."}
{"instruction": "Muestra algoritmo de Christofides con aproximación garantizada", "response": "MST ≤ OPT Emparejamiento ≤ 0.5*OPT Combinación ≤ 1.5*OPT Circuito Euleriano ≤ 2*MST Atajo ≤ MST+Emparejamiento ≤ 1.5*OPT"}
{"instruction": "¿Qué es 'algoritmo de Bland'?", "response": "Regla anticiclo para simplex. Selecciona variables entrantes/salientes con índices más pequeños. Garantiza convergencia pero lenta."}
{"instruction": "Explica 'problema de la mochila con recuperación de solución'", "response": "No solo valor máximo sino conjunto de items. PD con backtracking: mantener array previo o decisión en cada estado."}
{"instruction": "Define 'Quotient filter'", "response": "Alternativa Bloom filter más amigable a caché. Tres bits por entrada: occupied, continuation, shifted. Soporta deletions."}
{"instruction": "Muestra algoritmo de Dinic con dynamic trees", "response": "Usa árboles dinámicos (ST-trees) para enviar flujo en lotes grandes. O(VE log V) teórico, mejor en práctica para grafos grandes."}
{"instruction": "¿Qué es 'algoritmo de Cunningham'?", "response": "Para flujo máximo con capacidades enteras. Usa aumento de caminos cortos. O(V²E) pero simple de implementar."}
{"instruction": "Explica 'problema de la mochila con rotación de items'", "response": "Items pueden rotarse (orientación diferente cambia peso/valor). Problema 2D/3D bin packing con rotaciones permitidas."}
{"instruction": "Define 'Count-Min Sketch'", "response": "Estructura probabilística para estimar frecuencia en stream. Matriz d×w con hash functions. Sobreestima pero nunca subestima."}
{"instruction": "Muestra algoritmo de Hopcroft-Karp optimizado", "response": "BFS construye layered graph DFS múltiples caminos disjuntos en capas Paralelización posible en BFS/DFS fases"}
{"instruction": "¿Qué es 'algoritmo de Khachiyan' (elipsoide)?", "response": "Primer algoritmo polinomial para programación lineal. O(n^6L²) teórico, no práctico. Basado en método elipsoide."}
{"instruction": "Explica 'problema de la mochila con aprendizaje con bandidos'", "response": "Contextual bandits con restricción capacidad. Trade-off exploración-explotación mientras respeta límite capacidad."}
{"instruction": "Define 'Spectral Bloom Filter'", "response": "Bloom filter que estima frecuencia además de membresía. Usa counters mínimos en lugar de bits."}
{"instruction": "Muestra algoritmo de Karger para corte mínimo", "response": "while |V| > 2:     elegir arista aleatoria uniforme     contraer arista (fusionar extremos) return corte representado por aristas entre últimos 2 supervértices"}
{"instruction": "¿Qué es 'algoritmo de Karmarkar'?", "response": "Método punto interior para LP. O(n^3.5L) teórico, competidor simplex. Avanza por interior región factible."}
{"instruction": "Explica 'problema de la mochila con capacidad dinámica'", "response": "Capacidad cambia durante proceso (ej: vehículo consume combustible). Modelar como problema de control óptimo en tiempo discreto."}
{"instruction": "Define 'Priority sampling'", "response": "Muestreo para estimar sumas en streams. Asigna prioridades aleatorias, mantiene muestras con prioridad más baja. Estimador insesgado."}
{"instruction": "Muestra algoritmo de Borůvka para MST", "response": "MST vacío while >1 componente:     para cada componente:         encontrar arista más barata hacia otra componente     añadir todas estas aristas a MST     fusionar componentes"}
{"instruction": "¿Qué es 'algoritmo de Simplex'?", "response": "Método geométrico para LP. Recorre vértices del poliedro hacia óptimo. Exponencial en peor caso pero rápido en práctica."}
{"instruction": "Explica 'problema de la mochila con time-dependent weights'", "response": "Peso/valor cambia con tiempo. Items tienen ventanas temporales y perfiles de depreciación/apreciación."}
{"instruction": "Define 'Reservoir sampling'", "response": "Muestreo aleatorio de k elementos de stream desconocido tamaño. Cada elemento probabilidad k/n de estar en muestra final."}
{"instruction": "Muestra algoritmo de Karger-Stein", "response": "if n ≤ 6: calcular corte mínimo por fuerza bruta else:     t = ceil(1 + n/√2)     ejecutar 2 recursiones con contracción a t vértices     devolver mínimo de los dos cortes"}
{"instruction": "¿Qué es 'algoritmo de Farkas'?", "response": "Lema de Farkas: prueba infactibilidad en LP. Ax=b, x≥0 tiene solución sí y solo si yA≥0, yb<0 no tiene solución."}
{"instruction": "Explica 'problema de la mochila con compartimentos'", "response": "Mochila dividida en compartimentos con capacidades separadas. Cada item asignado a compartimento específico. PD multidimensional."}
{"instruction": "Define 'HyperLogLog'", "response": "Estimación cardinalidad en streams. Usa observación de ceros iniciales en hash. O(m) memoria para error ~1.04/√m."}
{"instruction": "Muestra algoritmo de Floyd para detección ciclos", "response": "tortuga = cabeza, liebre = cabeza while liebre != null y liebre.siguiente != null:     tortuga = tortuga.siguiente     liebre = liebre.siguiente.siguiente     if tortuga == liebre: return true // ciclo return false"}
{"instruction": "¿Qué es 'algoritmo de Dantzig-Wolfe'?", "response": "Descomposición para LP grande. Resuelve master problem con column generation. Útil para problemas con estructura especial."}
{"instruction": "Explica 'problema de la mochila con rendimientos decrecientes'", "response": "Valor marginal disminuye con más copias del mismo item. Función cóncava por item. PD con evaluación función no lineal."}
{"instruction": "Define 'MinHash'", "response": "Estimación similitud Jaccard entre sets. h_min(S)=mín_{x∈S} h(x) para hash function h. Pr[h_min(A)=h_min(B)] = Jaccard(A,B)."}
{"instruction": "Muestra algoritmo de Brent para detección ciclos", "response": "poder = 1; lam = 1; tortuga = cabeza; liebre = cabeza.siguiente while liebre != tortuga:     if poder == lam: tortuga = liebre; poder *= 2; lam = 0     liebre = liebre.siguiente; lam += 1 // lam es longitud ciclo"}
{"instruction": "¿Qué es 'algoritmo de Benders'?", "response": "Descomposición para MILP. Separa variables complicadas (enteras) de continuas. Master problem entero, subproblem lineal."}
{"instruction": "Explica 'problema de la mochila con elasticidad de capacidad'", "response": "Capacidad puede expandirse a costo. Pagar por capacidad extra. Optimizar trade-off costo expansión vs valor items."}
{"instruction": "Define 'LSH (Locality Sensitive Hashing)'", "response": "Familia hash donde elementos similares colisionan con alta probabilidad. Para búsqueda aproximada vecino más cercano."}
{"instruction": "Muestra algoritmo de Sollin (Borůvka paralelo)", "response": "Cada vértice inicia como componente while >1 componente:     paralelo para cada componente:         encontrar arista mínima saliente     añadir aristas (evitar duplicados)     fusionar componentes conectados"}
{"instruction": "¿Qué es 'algoritmo de Branch and Bound'?", "response": "Método exacto para optimización combinatoria. Ramifica en subproblemas, acota con relajaciones, poda subproblemas no prometedores."}
{"instruction": "Explica 'problema de la mochila con incertidumbre knightian'", "response": "Incertidumbre donde distribución probabilística desconocida. Robust optimization con worst-case sobre conjunto ambigüedad."}
{"instruction": "Define 'SimHash'", "response": "LSH para similitud coseno. Hash vector: signo(dot(v, r)) donde r vector aleatorio normal. Similar vectors tienen bits similares."}
{"instruction": "Muestra algoritmo de Pollard Rho para factorización", "response": "x=2, y=2, d=1 while d==1:     x = f(x) mod n     y = f(f(y)) mod n     d = gcd(|x-y|, n) if d!=n: d es factor"}
{"instruction": "¿Qué es 'algoritmo de Cutting Plane'?", "response": "Resuelve MILP añadiendo restricciones que cortan soluciones fraccionarias. Gomory cuts, cover cuts, etc."}
{"instruction": "Explica 'problema de la mochila con items perishables'", "response": "Items perecen después de tiempo, valor cae a 0. Incorporar vida útil y tiempo selección en modelo."}
{"instruction": "Define 'Count Sketch'", "response": "Estimador frecuencia en streams con signed updates. Similar Count-Min pero mejor para elementos con frecuencia negativa."}
{"instruction": "Muestra algoritmo de Z para strings", "response": "L=0, R=0 for i=1 to n-1:     if i > R:         L=R=i         while R<n y s[R-L]==s[R]: R++         Z[i]=R-L; R--     else:         k=i-L         if Z[k] < R-i+1: Z[i]=Z[k]         else: L=i; while R<n y s[R-L]==s[R]: R++; Z[i]=R-L; R--"}
{"instruction": "¿Qué es 'algoritmo de Feasibility Pump'?", "response": "Heurística para MILP. Alterna entre soluciones enteras (pero infactibles) y factibles (pero fraccionarias) hasta converger."}
{"instruction": "Explica 'problema de la mochila con costos de transacción'", "response": "Costo fijo por incluir item. Modelar con variable binaria adicional y costo setup en función objetivo."}
{"instruction": "Define 'Bloom filter contable'", "response": "Usa contadores en lugar de bits. Permite deletions pero más espacio. Overflow en contadores necesita manejo especial."}
{"instruction": "Muestra algoritmo de Aho-Corasick", "response": "1. Construir trie de patrones 2. Añadir enlaces falla (similar KMP) 3. Procesar texto recorriendo trie, siguiendo enlaces falla cuando no hay hijo 4. Reportar matches en nodos output"}
{"instruction": "¿Qué es 'algoritmo de Tabu Search'?", "response": "Metaheurística que explora vecindad, prohibiendo retornos recientes (lista tabú). Escapa óptimos locales."}
{"instruction": "Explica 'problema de la mochila con complementariedades'", "response": "Algunos items valen más juntos que separados (superaditividad). Función valor no separable. PD difícil."}
{"instruction": "Define 'Quadtree'", "response": "Árbol para subdividir espacio 2D. Cada nodo divide región en 4 cuadrantes. Para colisiones, compresión imágenes, etc."}
{"instruction": "Muestra algoritmo de Ukkonen para árbol sufijos", "response": "Algoritmo online O(n). Mantiene árbol implícito, procesa caracteres uno por uno, aplica reglas extensión: extensión simple, dividir hoja, dividir interno."}
{"instruction": "¿Qué es 'algoritmo de Simulated Annealing'?", "response": "Metaheurística inspirada recocido metálico. Acepta peores soluciones con probabilidad decreciente (temperatura)."}
{"instruction": "Explica 'problema de la mochila con sustituibilidad'", "response": "Items pueden sustituirse parcialmente. Función valor depende de combinaciones no solo presencia/ausencia."}
{"instruction": "Define 'Octree'", "response": "Extensión 3D de quadtree. Divide espacio en 8 octantes. Para gráficos 3D, procesamiento nubes puntos."}
{"instruction": "Muestra algoritmo de LCP array construcción", "response": "Dado suffix array SA y string S: rank[SA[i]] = i lcp = 0 for i=0 to n-1:     if rank[i] > 0:         j = SA[rank[i]-1]         while s[i+lcp]==s[j+lcp]: lcp++         LCP[rank[i]] = lcp         if lcp>0: lcp--"}
{"instruction": "¿Qué es 'algoritmo de Genetic Algorithm'?", "response": "Metaheurística evolutiva. Población de soluciones, selección, crossover, mutación. Fitness guía evolución hacia mejores."}
{"instruction": "Explica 'problema de la mochila con externalidades'", "response": "Valor de item afectado por qué otros items están presentes. Externalidades positivas/negativas entre items."}
{"instruction": "Define 'R-tree'", "response": "Árbol para objetos espaciales (rectángulos). Agrupa objetos cercanos en nodos con MBR (Minimum Bounding Rectangle). Para bases datos espaciales."}
{"instruction": "Muestra algoritmo de Farach para árbol sufijos", "response": "1. Construir suffix array de caracteres pares e impares recursivamente 2. Merge los dos suffix arrays 3. Construir árbol sufijos desde SA y LCP // Primer algoritmo lineal optimal para alfabeto general"}
{"instruction": "¿Qué es 'algoritmo de Ant Colony Optimization'?", "response": "Metaheurística inspirada hormigas. Feromonas en soluciones buenas atraen más 'hormigas'. Para TSP, scheduling."}
{"instruction": "Explica 'problema de la mochila con recursos renovables'", "response": "Capacidad se rellena parcialmente con tiempo (ej: energía solar). Modelar como problema de inventario dinámico."}
{"instruction": "Define 'Segment tree with lazy propagation'", "response": "Árbol segmentos que pospone actualizaciones hasta necesarias. O(log n) para range updates y queries."}
{"instruction": "Muestra algoritmo de McCreight para árbol sufijos", "response": "Construcción incremental O(n). Mantiene suffix link pointers. Más simple que Ukkonen pero mismo complejidad."}
{"instruction": "¿Qué es 'algoritmo de Particle Swarm Optimization'?", "response": "Metaheurística basada en enjambre. Partículas tienen posición y velocidad, se mueven hacia mejores posiciones personales y globales."}
{"instruction": "Explica 'problema de la mochila con aprendizaje por refuerzo'", "response": "Agente aprende política selección items con recompensa retardada. Q-learning o policy gradient con restricción capacidad."}
{"instruction": "Define 'Interval tree'", "response": "Árbol para intervalos donde nodo almacena intervalo y max extremo derecho en subárbol. Encuentra todos intervalos que solapan con punto O(log n)."}
{"instruction": "Muestra algoritmo de Weiner (primer árbol sufijos)", "response": "Algoritmo histórico O(n|Σ|). Construye árbol procesando sufijos en orden inverso, usando suffix links. Importante teóricamente."}
{"instruction": "¿Qué es 'algoritmo de Cuckoo Search'?", "response": "Metaheurística inspirada en comportamiento cuckoo. Usa Lévy flights para exploración y reemplazo de nidos (soluciones)."}
{"instruction": "Explica 'problema de la mochila con múltiples agentes'", "response": "Varios tomadores de decisiones con objetivos posiblemente conflictivos. Juego cooperativo o no cooperativo."}
{"instruction": "Define 'Segment tree beats'", "response": "Extensión árbol segmentos para operaciones no triviales (min, max, gcd con updates especiales). Mantiene múltiples valores por nodo."}
{"instruction": "Muestra algoritmo de SA-IS para suffix array", "response": "1. Clasificar sufijos como S/L tipos 2. Construir array reduced 3. Ordenar recursivamente reduced 4. Inducir orden completo // O(n) práctico y teórico"}
{"instruction": "¿Qué es 'algoritmo de Firefly Algorithm'?", "response": "Metaheurística basada en luciérnagas. Brillo atrae otras luciérnagas. Atracción decrece con distancia (absorción luz)."}
{"instruction": "Explica 'problema de la mochila con fairness constraints'", "response": "Garantizar distribución justa entre categorías (género, raza, etc.). Cuotas o proporciones mínimas/máximas por grupo."}
{"instruction": "Define 'Binary Indexed Tree para range updates", "response": "Usar dos BITs para soportar range updates y point queries. update(l,r,val): add(l,val), add(r+1,-val). query(i): sum hasta i."}
{"instruction": "Muestra algoritmo de KS (Ko-Aluru) para suffix array", "response": "Basado en divide y vencerás con S/L partitioning. Ordena S-sufijos y L-sufijos separadamente, luego merge. O(n log n)."}
{"instruction": "¿Qué es 'algoritmo de Bat Algorithm'?", "response": "Metaheurística basada en ecolocación murciélagos. Frecuencia, loudness, pulse rate controlan exploración/explotación."}
{"instruction": "Explica 'problema de la mochila con sostenibilidad'", "response": "Considerar impacto ambiental. Maximizar valor económico sujeto a límites huella carbono, agua, etc."}
{"instruction": "Define 'Wavelet tree'", "response": "Estructura para strings que soporta rank, select, access en O(log σ). Divide alfabeto recursivamente."}
{"instruction": "Muestra algoritmo de Larsson-Sadakane para suffix array", "response": "Variante de qsufsort. Usa induced sorting y recursion. O(n log n) worst-case pero rápido en práctica."}
{"instruction": "¿Qué es 'algoritmo de Grey Wolf Optimizer'?", "response": "Metaheurística basada en jerarquía manada lobos. Alpha, beta, delta guían omega wolves hacia presa."}
{"instruction": "Explica 'problema de la mochila con objetivos múltiples conflictivos'", "response": "Multi-objective optimization. Generar frente Pareto de soluciones no dominadas. NSGA-II, MOEA/D."}
{"instruction": "Define 'Suffix automaton'", "response": "Autómata determinista mínimo que reconoce todos sufijos de string. Tamaño O(n), construcción online."}
{"instruction": "Muestra algoritmo de DivSufSort para suffix array", "response": "Implementación eficiente de induced sorting. Divide sufijos en buckets por primer carácter, luego induce orden completo. Usado en libdivsufsort."}
{"instruction": "¿Qué es 'algoritmo de Whale Optimization Algorithm'?", "response": "Metaheurística basada en comportamiento ballenas jorobadas. Bubble-net feeding (exploitation) y búsqueda aleatoria (exploration)."}
{"instruction": "Explica 'problema de la mochila con incertidumbre fuzzy'", "response": "Valores/pesos como números fuzzy. Optimizar con criterios de ranking fuzzy o convertir a problema determinístico."}
{"instruction": "Define 'FM-index'", "response": "Índice comprimido basado en BWT (Burrows-Wheeler Transform). Soporta count, locate, extract en espacio pequeño."}
{"instruction": "Muestra algoritmo de BWT construcción", "response": "1. Añadir carácter terminal $ 2. Generar todas rotaciones 3. Ordenar lexicográficamente 4. Tomar última columna // Puede construirse desde suffix array: BWT[i] = S[SA[i]-1 mod n]"}
{"instruction": "¿Qué es 'algoritmo de Moth-Flame Optimization'?", "response": "Metaheurística basada en vuelo polillas hacia luz (llama). Moths spiral around flames, flames representan mejores soluciones."}
{"instruction": "Explica 'problema de la mochila con restricciones de gráfico'", "response": "Items representan vértices en grafo, restricciones en qué vértices pueden seleccionarse juntos (independent set, clique, etc.)."}
{"instruction": "Define 'BWT inversion'", "response": "Para reconstruir string original desde BWT:  1. Primera columna = ordenar BWT 2. Usar LF-mapping: LF(i) = rank(BWT[i]) + C(BWT[i]) 3. Comenzar desde $ y seguir LF mapping inverso"}
{"instruction": "Muestra algoritmo de backward search en FM-index", "response": "P = patrón sp = 1, ep = n for i=|P| downto 1:     c = P[i]     sp = C[c] + rank_c(sp-1) + 1     ep = C[c] + rank_c(ep)     if sp > ep: return not found return (sp, ep) // rango sufijos que empiezan con P"}
{"instruction": "¿Qué es 'algoritmo de Salp Swarm Algorithm'?", "response": "Metaheurística basada en enjambre salps (organismos marinos). Líder guía, followers forman cadena. Balance exploration/exploitation."}
{"instruction": "Explica 'problema de la mochila con restricciones de precedencia'", "response": "Algunos items requieren otros items primero (prerrequisitos). Grafo de precedencia, resolver como scheduling con capacidad."}
{"instruction": "Define 'Compressed suffix array (CSA)'", "response": "Representación comprimida de suffix array que soporta lookup eficiente. Ψ function, differential encoding, compression."}
{"instruction": "Muestra algoritmo de rank/select en wavelet tree", "response": "rank_c(i): recorrer árbol según bits de c, llevar contador select_c(k): subir desde hoja manteniendo posición // O(log σ) tiempo"}
{"instruction": "¿Qué es 'algoritmo de Artificial Bee Colony'?", "response": "Metaheurística basada en comportamiento abejas. Employed bees (exploitation), onlooker bees (selección), scout bees (exploration)."}
{"instruction": "Explica 'problema de la mochila con capacidad estocástica y recourse'", "response": "Capacidad aleatoria revelada gradualmente, decisiones pueden ajustarse (recourse). Programación estocástica de dos etapas."}
{"instruction": "Define 'LZ77 compression'", "response": "Compresión basada en diccionario deslizante. (offset, length, next_char). Encontrar match más largo en ventana deslizante."}
{"instruction": "Muestra algoritmo de LZ77 encoding", "response": "while hay entrada:     encontrar match más largo en ventana     if match encontrado: emitir (distancia, longitud, próximo_char)     else: emitir (0, 0, próximo_char)     desplazar ventana longitud+1"}
{"instruction": "¿Qué es 'algoritmo de Harmony Search'?", "response": "Metaheurística inspirada en improvisación musical. Memory考虑 (exploitation), pitch adjustment (local search), randomization (exploration)."}
{"instruction": "Explica 'problema de la mochila con items que expiran'", "response": "Items tienen fecha expiración, deben usarse antes. Incorporar tiempo en modelo, similar a inventory perishable."}
{"instruction": "Define 'LZ78/LZW'", "response": "LZ78: construye diccionario explícito. LZW: inicializa diccionario con todos caracteres, añade nuevas frases encontradas."}
{"instruction": "Muestra algoritmo de LZW encoding", "response": "diccionario = todos caracteres w = vacío for cada carácter c:     if w+c en diccionario: w = w+c     else: emitir código(w); añadir w+c a diccionario; w = c emitir código(w)"}
{"instruction": "¿Qué es 'algoritmo de Teaching-Learning Based Optimization'?", "response": "Metaheurística inspirada en aula. Teacher phase (mejor solución enseña), learner phase (estudiantes interactúan)."}
{"instruction": "Explica 'problema de la mochila con capacidad que depende de items'", "response": "Cada item consume capacidad diferente según orden o combinación. Función capacidad no aditiva."}
{"instruction": "Define 'Arithmetic coding'", "response": "Codificación entrópica que representa mensaje como intervalo real [0,1). Más eficiente que Huffman para distribuciones no dyadic."}
{"instruction": "Muestra algoritmo de arithmetic encoding", "response": "low=0, high=1 for cada símbolo s:     range = high - low     high = low + range * cum_high[s]     low = low + range * cum_low[s] emitir bits suficientes para identificar intervalo final"}
{"instruction": "¿Qué es 'algoritmo de Jaya'?", "response": "Metaheurística sin parámetros. Mueve soluciones hacia mejor solución y lejos de peor solución en cada iteración."}
{"instruction": "Explica 'problema de la mochila con restricciones de contigüidad en selección'", "response": "Items deben seleccionarse en bloques contiguos del conjunto original. Similar a subarray suma máxima pero con capacidad."}
{"instruction": "Define 'Range minimum query con tabla esparsa'", "response": "preprocesar O(n log n): st[i][j] = mínimo en [i, i+2^j-1] query O(1): k = floor(log2(r-l+1)); min(st[l][k], st[r-2^k+1][k])"}
{"instruction": "Muestra algoritmo de RMQ con árbol de segmentos", "response": "build(node, l, r):     if l==r: tree[node]=arr[l]     else: mid=(l+r)//2; build(2*node,l,mid); build(2*node+1,mid+1,r); tree[node]=min(tree[2*node],tree[2*node+1])"}
{"instruction": "¿Qué es 'algoritmo de Differential Evolution'?", "response": "Metaheurística evolutiva. Mutación basada en diferencia vectores, crossover binomial/ exponencial. Para optimización continua."}
{"instruction": "Explica 'problema de la mochila con capacidad divisible'", "response": "Mochila puede dividirse en compartimentos de tamaño variable. Similar a bin packing pero con optimización valor."}
{"instruction": "Define 'RMQ con técnica ±1 (RMQ de Cartesiano)'", "response": "Para arrays donde elementos adyacentes difieren en ±1. Convertir a LCA en árbol de Cartesiano, luego usar LCA O(1)."}
{"instruction": "Muestra algoritmo de LCA con binary lifting", "response": "preprocess: up[u][0]=parent, up[u][k]=up[up[u][k-1]][k-1] lca(u,v):     if depth[u]<depth[v]: swap     subir u a profundidad v     if u==v: return u     for k=log downto 0: if up[u][k]!=up[v][k]: u=up[u][k]; v=up[v][k]     return parent[u]"}
{"instruction": "¿Qué es 'algoritmo de Evolution Strategy'?", "response": "Algoritmo evolutivo enfocado en optimización continua. Auto-adapta parámetros mutación (σ). (μ,λ) o (μ+λ) selection."}
{"instruction": "Explica 'problema de la mochila con capacidad compartida'", "response": "Múltiples mochilas comparten capacidad global. Restricción coupling entre mochilas. PD con estado multidimensional grande."}
{"instruction": "Define 'Mo's algorithm'", "response": "Para responder queries offline en array. Ordenar queries por (block, r) donde block = l/√n, procesar con dos punteros. O((n+q)√n)."}
{"instruction": "Muestra Mo's algorithm paso a paso", "response": "1. block_size = sqrt(n) 2. ordenar queries por (l/block_size, r) (r decreciente si bloque impar) 3. curr_l=0, curr_r=-1 4. para cada query: while curr_l>l: add(--curr_l); while curr_r<r: add(++curr_r); while curr_l<l: remove(curr_l++); while curr_r>r: remove(curr_r--)"}
{"instruction": "¿Qué es 'algoritmo de CMA-ES'?", "response": "Covariance Matrix Adaptation Evolution Strategy. Aprende matriz covarianza de distribución búsqueda. Estado del arte optimización continua sin gradiente."}
{"instruction": "Explica 'problema de la mochila con capacidad que aprende'", "response": "Capacidad verdadera desconocida, se estima con muestras. Aprendizaje activo mientras se toman decisiones de selección."}
{"instruction": "Define 'SQRT decomposition para updates range, query point'", "response": "Dividir array en bloques tamaño √n. Para update(l,r,val): procesar bloques completos con lazy, elementos sobrantes individualmente. Query O(1)."}
{"instruction": "Muestra sqrt decomposition para sumas", "response": "block_size = ceil(sqrt(n)) block_sum[i] = sum elementos bloque i update(i,val): block_sum[i/bs] += val-arr[i]; arr[i]=val query(l,r): sum=0; procesar bloques completos usando block_sum, elementos sobrantes directamente"}
{"instruction": "¿Qué es 'algoritmo de Nelder-Mead'?", "response": "Método direct search para optimización no lineal. Simplex de n+1 puntos en R^n, operaciones: reflexión, expansión, contracción, reducción."}
{"instruction": "Explica 'problema de la mochila con restricciones de configuración'", "response": "Items deben ensamblarse en configuraciones válidas (ej: kits). Restricciones complejas de compatibilidad entre componentes."}
{"instruction": "Define 'Binary lifting para k-th ancestor'", "response": "preprocess: up[u][0]=parent, up[u][k]=up[up[u][k-1]][k-1] kth_ancestor(u,k): for i=0 to log: if k&(1<<i): u=up[u][i]; return u"}
{"instruction": "Muestra algoritmo de centroide de árbol", "response": "FUNCIÓN find_centroid(u, padre, n_total):     para cada vecino v ≠ padre:         si tamaño_subárbol[v] > n_total/2: devolver find_centroid(v, u, n_total)     devolver u // Hay 1 o 2 centroides"}
{"instruction": "¿Qué es 'algoritmo de Powell's method'?", "response": "Método dirección conjugada para optimización sin derivadas. Búsqueda lineal a lo largo de direcciones conjugadas."}
{"instruction": "Explica 'problema de la mochila con valor submodular'", "response": "Función valor submodular: rendimientos decrecientes marginales. NP-hard maximizar. Algoritmo greedy da (1-1/e)-aproximación."}
{"instruction": "Define 'Centroid decomposition'", "response": "Descomposición recursiva de árbol por centroides. Construye árbol centroid de altura O(log n). Para problemas de caminos en árbol."}
{"instruction": "Muestra query en árbol con centroid decomposition", "response": "1. Encontrar centroid C 2. Procesar todos caminos que pasan por C 3. Remover C, recursión en cada componente // Típico para problemas 'distancia entre nodos ≤ k'"}
{"instruction": "¿Qué es 'algoritmo de BFGS'?", "response": "Quasi-Newton method para optimización no lineal. Aproxima Hessian inverso usando updates secante. Muy usado en práctica."}
{"instruction": "Explica 'problema de la mochila con valor supermodular'", "response": "Sinergias: valor marginal aumenta con más items. Ej: colecciones complementarias. Más raro en práctica."}
{"instruction": "Define 'Heavy-light decomposition'", "response": "Descompone árbol en cadenas pesadas. Cada nodo a raíz pasa por O(log n) cadenas. Para queries/updates en camino."}
{"instruction": "Muestra HLD para LCA", "response": "1. Descomponer en cadenas 2. Para LCA(u,v): mientras en cadenas diferentes, subir cadena más profunda 3. Cuando en misma cadena, más bajo es LCA // Similar a binary lifting pero con cadenas"}
{"instruction": "¿Qué es 'algoritmo de L-BFGS'?", "response": "Limited-memory BFGS. Almacena solo m últimos updates para aproximar Hessian inverso. Para problemas grandes donde Hessian no cabe."}
{"instruction": "Explica 'problema de la mochila con capacidad que varía con items'", "response": "Cada item consume capacidad diferente según estado (ej: item comprimido/descomprimido). Opción de comprimir items con trade-off."}
{"instruction": "Define 'Euler tour technique'", "response": "Representar árbol como array via recorrido Euler. subtree de u corresponde a subarray continuo. Para queries subtree eficiente."}
{"instruction": "Muestra Euler tour para queries subtree", "response": "tin[u] = tiempo entrada tout[u] = tiempo salida subtree u = [tin[u], tout[u]] en array Euler Para query subtree: consultar segmento en árbol segmentos sobre array Euler"}
{"instruction": "¿Qué es 'algoritmo de Levenberg-Marquardt'?", "response": "Método para mínimos cuadrados no lineales. Interpolación entre Gauss-Newton y descenso gradiente. Usado en ajuste curvas."}
{"instruction": "Explica 'problema de la mochila con costos de oportunidad'", "response": "Incluir costo de no seleccionar otros items. Modelar como minimizar costo total en lugar de maximizar valor."}
{"instruction": "Define 'Small-to-large technique'", "response": "Para unir conjuntos en árbol: siempre unir conjunto más pequeño al más grande. Amortizado O(n log n) para n operaciones union."}
{"instruction": "Muestra DSU on tree (Sack)", "response": "FUNCIÓN dfs(u, keep):     para cada hijo v (excepto heavy child): dfs(v, false)     si heavy child existe: dfs(heavy, true)     añadir contribución u y light children     responder queries de u     si not keep: remover contribución subárbol"}
{"instruction": "¿Qué es 'algoritmo de Trust Region'?", "response": "Método optimización no lineal. Resuelve subproblema cuadrático en región de confianza, ajusta tamaño región según calidad aproximación."}
{"instruction": "Explica 'problema de la mochila con aversión a la pérdida'", "response": "Teoría prospectiva: pérdidas pesan más que ganancias. Función valor no lineal con punto referencia."}
{"instruction": "Define 'Divide and conquer on trees'", "response": "Resolver problema procesando centroid recursivamente. Típico para contar pares nodos con cierta propiedad (distancia, etc.)."}
{"instruction": "Muestra counting pairs distance ≤ k en árbol", "response": "1. Encontrar centroid C 2. Contar pares cuya ruta pasa por C (usando DFS desde C) 3. Remover C, recursión en componentes // O(n log n)"}
{"instruction": "¿Qué es 'algoritmo de Interior Point Methods'?", "response": "Clase métodos para optimización convexa. Recorren interior región factible hacia óptimo. Polinomiales, usados en LP, QP, SOCP."}
{"instruction": "Explica 'problema de la mochila con racionalidad limitada'", "response": "Tomador decisiones no perfectamente racional. Satisficing en lugar de optimizar, o heurísticas simples con límites cognitivos."}
{"instruction": "Define 'Rerooting technique'", "response": "Calcular algo para todos nodos como raíces. Primero DFS desde raíz arbitraria, luego segundo DFS propagando información hacia otras raíces."}
{"instruction": "Muestra rerooting para suma distancias a todos nodos", "response": "primero dfs1: tamaño_subárbol, sum_distancias_desde_raíz segundo dfs2: para vecino v de u: sum[v] = sum[u] + n - 2*tamaño[v] // sum[v] es suma distancias desde v a todos nodos"}
{"instruction": "¿Qué es 'algoritmo de Augmented Lagrangian'?", "response": "Método para optimización con restricciones. Combina Lagrangian con penalty term. Mejor convergencia que penalty methods puros."}
{"instruction": "Explica 'problema de la mochila con miopía'", "response": "Decisor ve solo parte de items a la vez (ventana limitada). Online algorithm con razón competitiva análisis."}
{"instruction": "Define 'Virtual trees'", "response": "Árbol construido con subset de nodos (ej: nodos query) preservando relaciones ancestro. Construcción O(k log k) usando LCA."}
{"instruction": "Muestra construcción virtual tree", "response": "1. Ordenar nodos por tin (Euler tour) 2. Pila con raíz 3. Para cada nodo u en orden:    - lca = LCA(u, top(pila))    - while depth[top-1] ≥ depth[lca]: conectar top-1 -> top, pop    - if lca ≠ top: conectar lca -> top, pop, push lca    - push u 4. Vaciar pila conectando restantes"}
{"instruction": "¿Qué es 'algoritmo de Alternating Direction Method of Multipliers (ADMM)'?", "response": "Método para optimización distribuida. Divide problema en subproblemas más simples coordinados con multiplicadores Lagrange."}
{"instruction": "Explica 'problema de la mochila con preferencias lexicográficas'", "response": "Ordenar items por prioridad, optimizar secuencialmente: primero maximizar contar items prioridad 1, luego prioridad 2 sujeto a eso, etc."}
{"instruction": "Define 'Dancing Links (DLX)'", "response": "Técnica para implementar Algorithm X de Knuth para exact cover. Listas circulares doblemente enlazadas para cobertura exacta eficiente."}
{"instruction": "Muestra Algorithm X con DLX", "response": "función search(profundidad):     si matriz vacía: solución encontrada     elegir columna c (heurística: mín 1s)     cover columna c     para cada fila r donde matriz[r][c]=1:         añadir r a solución         para cada columna j donde matriz[r][j]=1: cover j         recursión         deshacer cambios (uncover)     uncover columna c"}
{"instruction": "¿Qué es 'algoritmo de Stochastic Gradient Descent (SGD)'?", "response": "Optimización usando gradiente aproximado con mini-batch. Escala a datasets grandes. Base de deep learning."}
{"instruction": "Explica 'problema de la mochila con restricciones de diversidad'", "response": "Asegurar diversidad en conjunto seleccionado (ej: diferentes categorías, colores, estilos). Restricciones de cobertura o proporciones."}
{"instruction": "Define 'Bitmask DP para Hamiltonian path'", "response": "dp[mask][i] = existe camino visitando vértices en mask terminando en i. Inicializar dp[1<<i][i]=true. Transición: si dp[mask][i] y arista i->j y j no en mask: dp[mask|1<<j][j]=true."}
{"instruction": "Muestra DP para TSP con bitmask", "response": "dp[mask][i] = mínimo costo visitando vértices en mask terminando en i Inicializar dp[1<<inicio][inicio]=0 Para mask=0 to (1<<n)-1:     Para i=0 to n-1 si en mask:         Para j=0 to n-1 si no en mask y arista i->j:             dp[mask|1<<j][j]=min(dp[mask|1<<j][j], dp[mask][i]+dist[i][j]) Respuesta = mín_i dp[(1<<n)-1][i] + dist[i][inicio]"}
{"instruction": "¿Qué es 'algoritmo de Adam Optimizer'?", "response": "Adaptive Moment Estimation. Combina momentum con adaptive learning rates. Muy usado en deep learning."}
{"instruction": "Explica 'problema de la mochila con incertidumbre Knightian y aprendizaje'", "response": "Incertidumbre no probabilística que se reduce con información adquirida. Aprendizaje activo para reducir ambigüedad mientras decide."}
{"instruction": "Define 'Meet-in-the-middle para subset sum'", "response": "Dividir conjunto en dos mitades A y B. Generar todas sumas posibles en A y B. Ordenar B, para cada suma_a en A buscar target-suma_a en B con binary search. O(n*2^(n/2))."}
{"instruction": "Muestra meet-in-the-middle para 0/1 knapsack", "response": "1. Dividir items en dos mitades 2. Generar todos (peso, valor) posibles en cada mitad 3. Para mitad B, por cada peso mantener máximo valor (dominar soluciones inferiores) 4. Para cada (w1,v1) en A, buscar en B máximo v2 con w2 ≤ capacidad-w1"}
{"instruction": "¿Qué es 'algoritmo de RMSProp'?", "response": "Adaptive learning rate method. Divide gradiente por raíz media cuadrada móvil de gradientes pasados. Para non-stationary objectives."}
{"instruction": "Explica 'problema de la mochila con función valor no monótona'", "response": "Valor puede disminuir después de cierto punto (demasiado de algo malo). Función valor cóncava-convexa o unimodal."}
{"instruction": "Define 'Generating functions para DP optimizations'", "response": "Usar funciones generadoras para representar DP como coeficientes de polinomios. Convoluciones rápidas (FFT) para acelerar transitions."}
{"instruction": "Muestra FFT para convolución en DP", "response": "Si dp[i] = Σ dp[j]*coef[i-j] sobre j: Representar dp como polinomio D(x)=Σ dp[i]x^i Coef como polinomio C(x)=Σ coef[i]x^i Nuevo dp = inversaFFT( FFT(D) * FFT(C) ) // O(n log n) en lugar de O(n²)"}
{"instruction": "¿Qué es 'algoritmo de Adagrad'?", "response": "Adaptive gradient algorithm. Learning rate se adapta por parámetro: η/√(Σ g² acumulados). Para sparse gradients."}
{"instruction": "Explica 'problema de la mochila con interacciones de orden superior'", "response": "Valor depende de combinaciones de 3 o más items (interacciones ternarias, etc.). Modelo de orden superior difícil de optimizar."}
{"instruction": "Define 'Convex hull trick para DP optimizations'", "response": "Cuando transición DP es dp[i] = min(dp[j] + m[j]*x[i] + b[j]), mantener lower hull de líneas para query x[i] en O(log n)."}
{"instruction": "Muestra convex hull trick para líneas añadidas en orden pendiente", "response": "Mantener deque de líneas Al añadir nueva línea L:     while tamaño≥2 y intersección(L, deque[-2]) ≤ intersección(deque[-1], deque[-2]): pop back     push back L Query x: while tamaño≥2 y eval(deque[0], x) ≥ eval(deque[1], x): pop front     devolver eval(deque[0], x)"}
{"instruction": "¿Qué es 'algoritmo de Nesterov Accelerated Gradient'?", "response": "Método momentum con lookahead. Calcula gradiente en posición anticipada. Convergencia óptima para convex smooth."}
{"instruction": "Explica 'problema de la mochila con restricciones de justicia distributiva'", "response": "Distribuir beneficios entre múltiples stakeholders. Enfoques Rawlsian (maximin), utilitarista, Nash bargaining."}
{"instruction": "Define 'Divide and conquer DP optimization'", "response": "Para DP forma dp[i][j] = min(dp[i-1][k] + C[k][j]), si C satisface quadrangle inequality y monotonicidad, se puede resolver en O(n² log n)."}
{"instruction": "Muestra D&C DP para optimal binary search tree", "response": "función compute(l, r, optL, optR):     si l > r: return     mid = (l+r)//2     para k de optL a min(optR, mid-1):         calcular costo dp[mid][k]     encontrar mejor k (opt)     compute(l, mid-1, optL, opt)     compute(mid+1, r, opt, optR) // O(n²) en lugar de O(n³)"}
{"instruction": "¿Qué es 'algoritmo de Proximal Gradient Method'?", "response": "Para optimización con función objetivo f+g donde f smooth convex, g convex no necesariamente smooth (ej: L1 regularización)."}
{"instruction": "Explica 'problema de la mochila con externalidades de red'", "response": "Valor de item depende de cuántos otros tienen mismo item (efectos red). Modelar con externalidades positivas/negativas."}
{"instruction": "Define 'Knuth optimization para DP'", "response": "Para DP forma dp[i][j] = min(dp[i][k] + dp[k+1][j] + C[i][j]), si C satisface quadrangle inequality y monotonicidad, entonces opt[i][j-1] ≤ opt[i][j] ≤ opt[i+1][j]."}
{"instruction": "Muestra Knuth optimization para optimal BST", "response": "Inicializar opt[i][i] = i Para len=2 to n:     Para i=1 to n-len+1:         j = i+len-1         dp[i][j] = ∞         Para k de opt[i][j-1] a opt[i+1][j]:             costo = dp[i][k-1] + dp[k+1][j] + sum_freq[i..j]             si costo < dp[i][j]: dp[i][j]=costo; opt[i][j]=k // O(n²) en lugar de O(n³)"}
{"instruction": "¿Qué es 'algoritmo de Frank-Wolfe' (Conditional Gradient)?", "response": "Para optimización sobre conjuntos convexos. En cada iteración, resuelve linear optimization sobre conjunto, mueve hacia solución. Útil cuando proyección costosa."}
{"instruction": "Explica 'problema de la mochila con complementariedades asimétricas'", "response": "Item A complementa B, pero B no necesariamente complementa A. Grafo dirigido de complementariedades."}
{"instruction": "Define 'Aliens trick (binary search on Lagrange multiplier)'", "response": "Para problemas con restricciones: convertir a penalización vía multiplicador Lagrange, binary search en multiplicador para cumplir restricción."}
{"instruction": "Muestra aliens trick para knapsack con límite items", "response": "Función f(λ) = max_{S} (valor(S) - λ*|S|) sujeto a peso(S)≤W Binary search en λ hasta que |S| ≈ k // Convierte restricción cardinalidad en término en objetivo"}
{"instruction": "Muestra algoritmo de MCMC para sampling", "response": "1. Inicializar estado x0 2. Para t=0 a T-1:    - Proponer nuevo estado y ~ Q(y|xt) (distribución propuesta)    - Calcular α = min(1, P(y)Q(xt|y)/(P(xt)Q(y|xt)))    - Con probabilidad α: x_{t+1}=y, sino x_{t+1}=xt"}
{"instruction": "¿Qué es 'algoritmo de Metropolis-Hastings'?", "response": "Caso general MCMC. Distribución objetivo P(x), distribución propuesta Q(y|x). Aceptación α = min(1, P(y)Q(x|y)/(P(x)Q(y|x)))."}
{"instruction": "Explica 'problema de la mochila con correlación temporal'", "response": "Valores/pesos correlacionados en tiempo (series temporales). Modelar con procesos estocásticos (AR, Markov)."}
{"instruction": "Define 'Gibbs sampling'", "response": "MCMC especial donde muestreas cada variable condicional en las otras. Siempre acepta (α=1). Para distribuciones multivariadas."}
{"instruction": "Muestra Gibbs sampling para Ising model", "response": "Para cada sitio i en orden aleatorio:    P(x_i=+1 | vecinos) = 1/(1+exp(-2βΣ vecinos))    Muestrear x_i según esta probabilidad"}
{"instruction": "¿Qué es 'algoritmo de Hamiltonian Monte Carlo'?", "response": "MCMC que usa gradientes para propuestas más eficientes. Introduce variables momentum, simula dinámica Hamiltoniana."}
{"instruction": "Explica 'problema de la mochila con restricciones de cluster'", "response": "Items agrupados en clusters, restricciones sobre clusters seleccionados (ej: máximo 1 item por cluster, o cluster completo o nada)."}
{"instruction": "Define 'No-U-Turn Sampler (NUTS)'", "response": "Extensión HMC que adapta número de pasos de integración. Automático, no requiere ajustar parámetros de integración."}
{"instruction": "Muestra algoritmo de Slice sampling", "response": "Dado x0: 1. Muestrear y ~ Uniform(0, f(x0)) (slice level) 2. Encontrar intervalo I alrededor x0 donde f(x) ≥ y 3. Muestrear x1 ~ Uniform(I)"}
{"instruction": "¿Qué es 'algoritmo de Belief Propagation'?", "response": "Pasa mensajes en grafo factor para inferencia aproximada. Para Markov random fields, Bayesian networks."}
{"instruction": "Explica 'problema de la mochila con learning from demonstrations'", "response": "Aprender función valor o restricciones a partir de ejemplos de decisiones humanas. Inverse reinforcement learning."}
{"instruction": "Define 'Variational Inference'", "response": "Aproximar distribución posterior con familia paramétrica q(z;λ). Minimizar KL(q||p) equivalente a maximizar ELBO."}
{"instruction": "Muestra CAVI para mixture Gaussians", "response": "E-step: q(z_i=k) ∝ π_k N(x_i|μ_k,σ_k) M-step: π_k, μ_k, σ_k basado en responsabilidades esperadas Iterar hasta convergencia"}
{"instruction": "¿Qué es 'algoritmo de Expectation Propagation'?", "response": "Aproximación variacional donde factores individuales son aproximados. Pasa mensajes como BP pero con proyección KL reversa."}
{"instruction": "Explica 'problema de la mochila con restricciones de privacidad'", "response": "No revelar qué items fueron seleccionados. Encriptación homomórfica o differential privacy en proceso decisión."}
{"instruction": "Define 'Markov Chain Monte Carlo Tree Search (MCTS)'", "response": "Combina MCMC con tree search para juegos/planificación. Cuatro fases: selection, expansion, simulation, backpropagation."}
{"instruction": "Muestra UCT (Upper Confidence Trees)", "response": "Selection: elegir hijo que maximice Q(s,a) + c√(ln N(s)/N(s,a)) Expansion: añadir nuevo nodo Simulation: rollout aleatorio Backpropagation: actualizar Q y N"}
{"instruction": "¿Qué es 'algoritmo de AlphaZero'?", "response": "Combina MCTS con red neuronal para policy y value. Self-play, aprendizaje por refuerzo. Para juegos como Go, Chess."}
{"instruction": "Explica 'problema de la mochila con restricciones de equidad de grupo'", "response": "Garantizar resultados justos para grupos demográficos (fairness constraints). Restricciones statistical parity, equal opportunity."}
{"instruction": "Define 'Thompson sampling'", "response": "Algoritmo Bayesian para bandit problems. Muestrear parámetros de distribución posterior, elegir acción óptima para parámetros muestreados."}
{"instruction": "Muestra Thompson sampling para Bernoulli bandits", "response": "Inicializar α_k=1, β_k=1 para cada brazo k Para cada tiempo t:    Muestrear θ_k ~ Beta(α_k, β_k) para cada k    Elegir brazo a = argmax θ_k    Observar recompensa r (0 o 1)    Actualizar α_a += r, β_a += 1-r"}
{"instruction": "¿Qué es 'algoritmo de UCB (Upper Confidence Bound)'?", "response": "Para bandit problems. Elegir brazo que maximiza media empírica + √(2 ln t / n_i) donde n_i es número de pulls del brazo i."}
{"instruction": "Explica 'problema de la mochila con adversarios'", "response": "Alguien puede sabotear items (valor negativo) o información es manipulada. Juego entre seleccionador y adversario."}
{"instruction": "Define 'LinUCB para contextual bandits'", "response": "UCB en espacio de características. Asume recompensa lineal en características contexto. Usa ridge regression para estimar."}
{"instruction": "Muestra LinUCB paso a paso", "response": "Inicializar A = I_d, b = 0_d Para cada t:    Obtener contexto x_t,a para cada brazo a    θ_a = A^{-1}b    p_t,a = x_t,a^T θ_a + α√(x_t,a^T A^{-1} x_t,a)    Elegir a = argmax p_t,a    Observar recompensa r_t    A += x_t,a x_t,a^T, b += r_t x_t,a"}
{"instruction": "¿Qué es 'algoritmo de EXP3'?", "response": "Para adversarial bandits. Mantiene weights sobre acciones, muestrea proporcional a weights, actualiza con pérdidas estimadas."}
{"instruction": "Explica 'problema de la mochila con restricciones de presupuesto de atención'", "response": "Tomador de decisiones tiene limitada atención/cognición. Modelar con costo de procesar información sobre items."}
{"instruction": "Define 'Gradient Bandit Algorithm'", "response": "Basado en gradiente. Política softmax: π(a) ∝ exp(H_t(a)). Actualizar: H_{t+1}(a) = H_t(a) + α(r_t - r̄_t)(1-π_t(a)) para a elegida."}
{"instruction": "Muestra Q-learning", "response": "Inicializar Q(s,a) arbitrariamente Para cada episodio:    Inicializar s    Para cada paso:       Elegir a de s usando política (ϵ-greedy)       Tomar a, observar r, s'       Q(s,a) ← Q(s,a) + α[r + γ max_a' Q(s',a') - Q(s,a)]       s ← s'"}
{"instruction": "¿Qué es 'algoritmo de SARSA'?", "response": "Similar Q-learning pero usa la acción realmente tomada en siguiente paso: Q(s,a) ← Q(s,a) + α[r + γ Q(s',a') - Q(s,a)] donde a' es próxima acción según política."}
{"instruction": "Explica 'problema de la mochila con aprendizaje por refuerzo multi-agente'", "response": "Múltiples agentes seleccionando items cooperativamente o competitivamente. Game theory + MARL."}
{"instruction": "Define 'Policy Gradient Theorem'", "response": "∇J(θ) = E[∑ ∇_θ log π_θ(a|s) Q^π(s,a)]. Gradiente de rendimiento es expectativa de score function veces función valor."}
{"instruction": "Muestra REINFORCE algorithm", "response": "1. Generar trayectoria siguiendo π_θ 2. Para cada paso t: calcular return G_t = ∑_{k=t}^T γ^{k-t} r_k 3. Actualizar θ ← θ + α∑_t γ^t G_t ∇_θ log π_θ(a_t|s_t)"}
{"instruction": "¿Qué es 'algoritmo de Actor-Critic'?", "response": "Combina policy gradient (actor) con value function approximator (critic). Actor actualiza política, critic evalua calidad acciones."}
{"instruction": "Explica 'problema de la mochila con restricciones de explicabilidad'", "response": "Decisión debe ser explicable a humanos. Modelos interpretables (árboles, reglas) o post-hoc explanations (SHAP, LIME)."}
{"instruction": "Define 'Proximal Policy Optimization (PPO)'", "response": "Policy gradient con clipped objective para estabilidad. Maximizar L(θ) = E[min(r(θ)Â, clip(r(θ),1-ε,1+ε)Â)] donde r(θ)=π_θ/π_θ_old."}
{"instruction": "Muestra PPO-clip algoritmo", "response": "Para iteración=1,2,...:    Colectar trayectorias con política π_θ_old    Calcular ventajas Â_t    Optimizar L(θ) sobre K epochs con minibatches    θ_old ← θ"}
{"instruction": "¿Qué es 'algoritmo de Deep Q-Network (DQN)'?", "response": "Q-learning con red neuronal para aproximar Q-function. Usa experience replay y target network para estabilidad."}
{"instruction": "Explica 'problema de la mochila con incertidumbre en las preferencias'", "response": "Utilidad del decisor es incierta incluso para sí mismo. Modelar con múltiples criterios o distribución sobre funciones utilidad."}
{"instruction": "Define 'Soft Actor-Critic (SAC)'", "response": "Algoritmo RL off-policy que maximiza expected return y entropía. Para exploración robusta. Actor stocástico, critic twin Q-networks."}
{"instruction": "Muestra SAC objetivo de entrenamiento", "response": "Critic loss: J_Q(θ) = E[(Q(s,a) - (r + γ(min Q_target(s',ã) - α log π(ã|s'))))²] Policy loss: J_π(φ) = E[α log π_φ(a|s) - Q_θ(s,a)] Temperature loss: J(α) = E[-α log π(a|s) - αH̄]"}
{"instruction": "¿Qué es 'algoritmo de Twin Delayed DDPG (TD3)'?", "response": "Extensión DDPG para reducir overestimation bias. Twin Q-networks, delayed policy updates, target policy smoothing."}
{"instruction": "Explica 'problema de la mochila con restricciones de sostenibilidad intergeneracional'", "response": "Considerar impacto en generaciones futuras. Modelar como problema intertemporal con discount rate ético."}
{"instruction": "Define 'Deterministic Policy Gradient (DDPG)'", "response": "Actor-Critic para espacios acción continuos. Actor determinístico μ(s), critic Q(s,a). Off-policy con experience replay."}
{"instruction": "Muestra TRPO (Trust Region Policy Optimization)", "response": "Maximizar expected advantage sujeto a KL(π_old||π_new) ≤ δ Resolver con conjugate gradient y line search Más estable que vanilla policy gradient"}
{"instruction": "¿Qué es 'algoritmo de A3C (Asynchronous Advantage Actor-Critic)'?", "response": "Variante distribuida de Actor-Critic. Múltiples workers asíncronos actualizando shared global network."}
{"instruction": "Explica 'problema de la mochila con restricciones de trayectoria'", "response": "Items deben seleccionarse en secuencia específica o con dependencias temporales. Problema de scheduling con capacidades."}
{"instruction": "Define 'Model-Based RL'", "response": "Aprende modelo de transiciones y recompensas, luego planifica usando modelo. Ejemplos: Dyna, MB-MPO, World Models."}
{"instruction": "Muestra Dyna-Q", "response": "1. Aprender Q(s,a) con Q-learning 2. Aprender modelo T(s,a)→s', R(s,a) 3. Planificación: repetir k veces: muestrear (s,a) de experience, predecir s',r usando modelo, actualizar Q(s,a) usando valores simulados"}
{"instruction": "¿Qué es 'algoritmo de Curiosity-Driven Exploration'?", "response": "Exploración basada en novelty o prediction error. Recompensa intrínseca = error predicción modelo next state."}
{"instruction": "Explica 'problema de la mochila con restricciones de liquidez'", "response": "Items requieren pago inicial pero generan flujos futuros. Restricciones cash flow a través del tiempo."}
{"instruction": "Define 'Hierarchical RL'", "response": "Divide tarea en subtareas con diferentes time scales. Opciones (options) o meta-learning."}
{"instruction": "Muestra Option Framework", "response": "Opción = (I, π, β) donde: I ⊆ S (initiation set) π: S→A (policy) β: S→[0,1] (termination condition) SMDP Q-learning: Q(s,o) actualizado cada vez opción termina"}
{"instruction": "¿Qué es 'algoritmo de FeUdal Networks'?", "response": "Arquitectura hierarchical RL con manager y worker. Manager establece goals, worker ejecuta acciones para alcanzar goals."}
{"instruction": "Explica 'problema de la mochila con restricciones de riesgo condicional'", "response": "Value-at-Risk (VaR) o Conditional Value-at-Risk (CVaR) constraints. Probabilidad de pérdida grande limitada."}
{"instruction": "Define 'Inverse Reinforcement Learning'", "response": "Dadas demostraciones expertas, inferir función recompensa que explica comportamiento. Maximum entropy IRL, apprenticeship learning."}
{"instruction": "Muestra Maximum Entropy IRL", "response": "Encontrar recompensa R que maximiza probabilidad demostraciones D: P(D|R) ∝ exp(∑_{τ∈D} R(τ)) Resolver con gradient descent o linear programming"}
{"instruction": "¿Qué es 'algoritmo de Generative Adversarial Imitation Learning (GAIL)'?", "response": "Combina IRL con GANs. Discriminador distingue entre demostraciones expertas y trayectorias agente, generador (policy) intenta engañar discriminador."}
{"instruction": "Explica 'problema de la mochila con restricciones de no convexidad'", "response": "Región factible no convexa (debido a restricciones lógicas, conjuntos desconectados). Difícil para métodos convencionales."}
{"instruction": "Define 'Meta-Learning (Learning to Learn)'", "response": "Aprender a aprender rápidamente nuevas tareas. MAML, Reptile, meta-gradient."}
{"instruction": "Muestra MAML (Model-Agnostic Meta-Learning)", "response": "1. Sample batch of tasks T_i 2. Para cada tarea: calcular gradiente ∇L_i(f_θ) (inner loop) 3. Actualizar θ ← θ - β∇_θ Σ L_i(f_{θ-α∇L_i}) (outer loop) // Aprende inicialización que permite rápida adaptación"}
{"instruction": "¿Qué es 'algoritmo de Reptile'?", "response": "Meta-learning más simple que MAML. Repetidamente: sample task, tomar múltiples gradient steps, mover parámetros hacia dirección final."}
{"instruction": "Explica 'problema de la mochila con restricciones de causalidad'", "response": "No solo correlación sino causalidad entre variables. Decisiones deben respetar relaciones causales (do-calculus)."}
{"instruction": "Define 'Transfer Learning'", "response": "Usar conocimiento de tarea fuente para acelerar aprendizaje en tarea objetivo. Fine-tuning, feature extraction, domain adaptation."}
{"instruction": "Muestra fine-tuning de red neuronal", "response": "1. Entrenar en dataset grande (tarea fuente) 2. Reemplazar última capa para nueva tarea 3. Continuar entrenamiento en dataset pequeño (tarea objetivo) con learning rate bajo 4. Opcional: unfreeze capas superiores gradualmente"}
{"instruction": "¿Qué es 'algoritmo de Domain Adaptation'?", "response": "Transfer learning donde distribución fuente y objetivo difieren. Mapear a espacio común donde distribuciones sean similares."}
{"instruction": "Explica 'problema de la mochila con restricciones de robustez adversarial'", "response": "Decisión debe ser robusta a perturbaciones adversarias en inputs (pesos/valores). Robust optimization con perturbaciones acotadas."}
{"instruction": "Define 'Multi-Task Learning'", "response": "Aprender múltiples tareas simultáneamente compartiendo representaciones. Hard parameter sharing o soft sharing."}
{"instruction": "Muestra hard parameter sharing MTL", "response": "Capas compartidas para todas tareas Capas específicas por tarea Loss total = Σ λ_i L_i Entrenar conjuntamente optimizando loss total"}
{"instruction": "¿Qué es 'algoritmo de Continual Learning'?", "response": "Aprender secuencia de tareas sin olvidar tareas anteriores. Elastic Weight Consolidation (EWC), Progressive Neural Networks."}
{"instruction": "Explica 'problema de la mochila con restricciones de no anticipación'", "response": "Decisor no puede anticipar información futura perfectamente. Online algorithm con competitive ratio analysis."}
{"instruction": "Define 'Elastic Weight Consolidation (EWC)'", "response": "Para continual learning. Añade penalty quadratic basada en importancia parámetros para tareas anteriores: L(θ) = L_nueva(θ) + λΣ F_i (θ_i - θ*_i)^2 donde F_i es Fisher information."}
{"instruction": "Muestra EWC regularización", "response": "Después de aprender tarea A con parámetros θ*_A: Calcular F_i (Fisher information diagonal) para cada parámetro Al aprender tarea B: L(θ) = L_B(θ) + (λ/2) Σ_i F_i (θ_i - θ*_A,i)^2"}
{"instruction": "¿Qué es 'algoritmo de Progressive Neural Networks'?", "response": "Para continual learning. Añade nueva red para cada tarea, con conexiones lateral a redes anteriores (frozen). Sin forgetting pero crece."}
{"instruction": "Explica 'problema de la mochila con restricciones de parcial observabilidad'", "response": "Solo se observa parte del estado (valor/ peso verdadero). POMDP formulation."}
{"instruction": "Define 'Partially Observable MDP (POMDP)'", "response": "Tupla (S,A,O,T,R,Ω,γ) donde O son observaciones, Ω son probabilidades observación. Mantener belief state b(s) = P(s|historia)."}
{"instruction": "Muestra POMDP belief update", "response": "b'(s') ∝ Ω(o|s',a) Σ_s T(s'|s,a) b(s) Después de tomar acción a y observar o Requiere mantener distribución sobre estados (belief)"}
{"instruction": "¿Qué es 'algoritmo de QMDP'?", "response": "Aproximación POMDP que asume full observabilidad después de un paso. Q(b,a) = Σ_s b(s) Q_MDP(s,a). Subóptimo pero computable."}
{"instruction": "Explica 'problema de la mochila con restricciones de compromiso (commitment)'", "response": "Decisión inicial puede restringir decisiones futuras. Modelar como juego secuencial con commitment power."}
{"instruction": "Define 'Point-Based Value Iteration (PBVI)'", "response": "Algoritmo POMDP que mantiene value function sobre belief space representada como conjunto de vectors α, muestrea beliefs reachable."}
{"instruction": "Muestra PBVI básico", "response": "1. Inicializar conjunto de puntos belief B 2. Para cada b en B: calcular α-vector greedy para b 3. Expandir B con nuevas beliefs reachable 4. Repetir hasta convergencia"}
{"instruction": "¿Qué es 'algoritmo de DESPOT'?", "response": "Determinized Sparse Partially Observable Tree. Para POMDPs grandes. Muestrea escenarios determinizados, busca árbol online."}
{"instruction": "Explica 'problema de la mochila con restricciones de tiempo real'", "response": "Decisión debe tomarse dentro de límite tiempo estricto. Anytime algorithms o algoritmos con tiempo de ejecución acotado."}
{"instruction": "Define 'Monte Carlo Tree Search para POMDP'", "response": "Extensión MCTS a POMDPs. Nodos son histories, edges son acciones-observaciones, rollout con creencia actual."}
{"instruction": "Muestra POMCP (POMCPOW)", "response": "Similar MCTS pero con belief particles en cada nodo Selection basada en UCB sobre histories Rollout con policy default Backpropagation actualiza valores Usa particle filter para belief update"}
{"instruction": "¿Qué es 'algoritmo de Bayes-Adaptive POMDP'?", "response": "POMDP donde estado incluye parámetros desconocidos del modelo. Aprender modelo mientras actúa. Estado aumentado (s, θ)."}
{"instruction": "Explica 'problema de la mochila con restricciones de información asimétrica'", "response": "Diferentes actores tienen información diferente. Signaling games, mechanism design para revelar información."}
{"instruction": "Define 'Mechanism Design'", "response": "Diseñar reglas de juego (mecanismo) para lograr objetivo social dado agentes estratégicos con información privada."}
{"instruction": "Muestra Vickrey-Clarke-Groves (VCG) mechanism", "response": "1. Agentes reportan valuations 2. Elegir asignación que maximiza suma valuations 3. Cada agente paga = (suma valuations otros sin agente) - (suma valuations otros con agente) Truthful revelation es estrategia dominante"}
{"instruction": "¿Qué es 'algoritmo de Myerson Auction'?", "response": "Optimal auction para vender un item a compradores con valuations independientes. Asignar a comprador con mayor virtual valuation si positiva, cobrar threshold price."}
{"instruction": "Explica 'problema de la mochila con restricciones de incentivos'", "response": "Agentes pueden reportar información falsa para manipular resultado. Diseñar mecanismo incentive-compatible (truthful)."}
{"instruction": "Define 'Reinforcement Mechanism Design'", "response": "Aprender mecanismo óptimo mediante interacción repetida con agentes. Combinar RL con game theory."}
{"instruction": "Muestra aprendizaje de mecanismo con RL", "response": "Agente principal (designer) elige mecanismo Agentes jugadores responden estratégicamente Designer observa resultados, actualiza policy para maximizar objetivo Equilibrio aprendido"}
{"instruction": "¿Qué es 'algoritmo de Multi-Armed Bandit Mechanism Design'?", "response": "Bandit problems donde brazos son agentes estratégicos. Combinar exploración-explotación con incentivos."}
{"instruction": "Explica 'problema de la mochila con restricciones de equilibrio de mercado'", "response": "Items pueden comprarse/venderse en mercado, precios determinan disponibilidad. Equilibrium computation (Walrasian)."}
{"instruction": "Define 'Fisher Market Model'", "response": "Mercado donde compradores tienen presupuestos, vendedores tienen items. Precios de equilibrio asignan items, agotan presupuestos."}
{"instruction": "Muestra tatonnement process", "response": "1. Inicializar precios p 2. Calcular demanda excesiva z(p) = Σ demanda_i(p) - oferta 3. Ajustar precios: p_j ← p_j + λ z_j(p) 4. Repetir hasta z(p) ≈ 0"}
{"instruction": "¿Qué es 'algoritmo de Proportional Response Dynamics'?", "response": "Para Fisher markets con utility functions linear. Agentes ajustan bids proporcionalmente a utility recibida. Converge a equilibrium."}
{"instruction": "Explica 'problema de la mochila con restricciones de matching'", "response": "Items deben emparejarse con agentes (one-to-one matching). Stable marriage, assignment problems."}
{"instruction": "Define 'Gale-Shapley Algorithm'", "response": "Encuentra stable matching. Procesa propuestas: cada hombre propone a mujer preferida, cada mujer mantiene mejor oferta hasta el momento. Termina en matching estable."}
{"instruction": "Muestra Gale-Shapley paso a paso", "response": "Inicializar todos hombres libres while existe hombre m libre:    mujer w = primera en lista preferencias m no propuesta    si w libre: emparejar (m,w)    sino si w prefiere m sobre current partner m': desemparejar (m',w), emparejar (m,w), liberar m'    sino: m sigue libre (rechazado)"}
{"instruction": "¿Qué es 'algoritmo de Hungarian Method'?", "response": "Resuelve assignment problem (matching perfecto mínimo/máximo costo) en O(n³). Reduce matriz con row/column operations."}
{"instruction": "Explica 'problema de la mochila con restricciones de asignación justa'", "response": "Distribuir items entre agentes de manera equitativa (fair division). Cake-cutting algorithms, envy-freeness."}
{"instruction": "Define 'Cut-and-Choose protocol'", "response": "Para fair division entre 2 agentes. Uno divide en 2 partes (que considera iguales), el otro elige parte. Garantiza proportionality."}
{"instruction": "Muestra Selfridge–Conway procedure", "response": "Para 3 agentes, envy-free allocation: 1. Agente 1 divide en 3 partes iguales 2. Agente 2 trima parte más grande para igualar segunda 3. Agente 3 elige, luego agente 2, luego agente 1 4. Trimmings divididos por procedure recursiva"}
{"instruction": "¿Qué es 'algoritmo de Stromquist Moving-Knife'?", "response": "Procedimiento continuo para envy-free division entre 3 agentes. Knife se mueve continuamente, agentes pueden decir 'stop'."}
{"instruction": "Explica 'problema de la mochila con restricciones de participación voluntaria'", "response": "Agentes pueden optar por no participar si utility esperada negativa. Individual rationality constraint."}
{"instruction": "Define 'Nash Bargaining Solution'", "response": "Solución a problema bargaining que maximiza producto de ganancias sobre disagreement point: argmax (u1-d1)(u2-d2)."}
{"instruction": "Muestra Nash bargaining con transferencias", "response": "Si utility transferible: maximizar suma utilities sujeto a factibilidad Luego dividir ganancias igualmente o según poder negociación"}
{"instruction": "¿Qué es 'algoritmo de Kalai-Smorodinsky'?", "response": "Solución bargaining que iguala ratios de ganancias a ganancias máximas posibles: u1/d1 = u2/d2 = ... sujeto a frontera Pareto."}
{"instruction": "Explica 'problema de la mochila con restricciones de coalición'", "response": "Agentes pueden formar coaliciones para obtener mejor resultado. Core, Shapley value, nucleolus."}
{"instruction": "Define 'Shapley Value'", "response": "Valor justo para agente en juego cooperativo: φ_i(v) = Σ_{S⊆N {i}} |S|!(n-|S|-1)!/n! [v(S∪{i}) - v(S)]"}
{"instruction": "Muestra cálculo Shapley Value para 3 agentes", "response": "Para agente A: S={}: v(A)-v(∅) S={B}: v(AB)-v(B) S={C}: v(AC)-v(C) S={B,C}: v(ABC)-v(BC) Promediar con pesos: 1/3 cada orden donde A es primero, segundo o tercero"}
{"instruction": "¿Qué es 'algoritmo de Core'?", "response": "Conjunto de asignaciones donde ninguna coalición puede mejorar desviándose. Puede estar vacío. Verificar con linear programming."}
{"instruction": "Explica 'problema de la mochila con restricciones de dinámica poblacional'", "response": "Agentes replican estrategias exitosas (evolutionary game theory). Equilibrios evolutivamente estables (ESS)."}
{"instruction": "Define 'Replicator Dynamics'", "response": "Ecuaciones diferenciales para fracción población usando estrategia i: dx_i/dt = x_i(f_i(x) - f̄(x)) donde f_i es fitness estrategia i, f̄ es fitness promedio."}
{"instruction": "Muestra ESS condición", "response": "Estrategia σ* es ESS si: 1. Equilibrio Nash: u(σ*,σ*) ≥ u(σ,σ*) ∀σ 2. Estabilidad: si u(σ*,σ*) = u(σ,σ*), entonces u(σ*,σ) > u(σ,σ)"}
{"instruction": "¿Qué es 'algoritmo de Fictitious Play'?", "response": "Agentes juegan mejor respuesta a distribución empírica oponentes. Converge a equilibrio en algunos juegos."}
{"instruction": "Explica 'problema de la mochila con restricciones de racionalidad limitada iterada'", "response": "Agentes modelan racionalidad limitada de otros agentes (level-k reasoning, cognitive hierarchy)."}
{"instruction": "Define 'Level-k Thinking'", "response": "Level-0: estrategia aleatoria Level-1: mejor respuesta a Level-0 Level-2: mejor respuesta a Level-1 ... Empíricamente humanos suelen ser Level-1 o 2"}
{"instruction": "Muestra Cognitive Hierarchy model", "response": "Asume distribución Poisson sobre niveles k Cada nivel k cree otros están distribuidos según Poisson truncado en k-1 Mejor respuesta a creencia sobre distribución niveles"}
{"instruction": "¿Qué es 'algoritmo de Quantal Response Equilibrium (QRE)'?", "response": "Equilibrio donde jugadores responden estocásticamente con probabilidades proporcionales a exponencial de payoff esperado: P(a_i) ∝ exp(λ u_i(a_i,σ_{-i}))."}
{"instruction": "Explica 'problema de la mochila con restricciones de atención limitada en juego'", "response": "Agentes no consideran todas estrategias posibles, sino subset (consideration sets). Equilibrio con limited attention."}
{"instruction": "Define 'Beauty Contest Game'", "response": "Juego donde cada jugador elige número en [0,100], gana quien esté más cerca de p veces promedio, donde p<1. Test para level-k reasoning."}
{"instruction": "Muestra solución iterada Beauty Contest", "response": "Level-0: elegir aleatorio Level-1: elegir 50p (asumiendo otros aleatorios) Level-2: elegir 50p² ... Level-k: elegir 50p^k Equilibrio Nash: todos eligen 0"}
{"instruction": "¿Qué es 'algoritmo de No-Regret Learning'?", "response": "Algoritmos donde regret promedio tiende a 0. Hedge, EXP3, Follow-the-Regularized-Leader (FTRL)."}
{"instruction": "Explica 'problema de la mochila con restricciones de aprendizaje en juegos repetidos'", "response": "Agentes aprenden de interacciones repetidas. Convergencia a equilibrio (fictitious play, no-regret dynamics)."}
{"instruction": "Define 'Hedge Algorithm'", "response": "Para prediction with expert advice. Inicializar weights w_i=1. Para cada tiempo: elegir experto con probabilidad proporcional a weight, actualizar w_i ← w_i exp(-η pérdida_i)."}
{"instruction": "Muestra FTRL (Follow-the-Regularized-Leader)", "response": "En tiempo t: elegir x_t = argmin_x (Σ_{s=1}^{t-1} f_s(x) + R(x)) Donde f_s son pérdidas, R es regularizador (ej: 1/2η||x||²) Regret O(√T) con learning rate apropiado"}
{"instruction": "¿Qué es 'algoritmo de Multiplicative Weights Update'?", "response": "Generalización de Hedge. Mantener distribution sobre acciones, actualizar multiplicativamente basado en pérdidas. Usado en optimization, game theory."}
{"instruction": "Explica 'problema de la mochila con restricciones de correlación en juegos'", "response": "Estrategias correlacionadas permitidas (correlated equilibrium). Más amplio que Nash equilibrium, puede lograr mejor social welfare."}
{"instruction": "Define 'Correlated Equilibrium'", "response": "Distribución conjunta σ sobre perfiles acción donde para cada jugador i y desviación a_i': E_{a∼σ}[u_i(a_i,a_{-i})] ≥ E_{a∼σ}[u_i(a_i',a_{-i}) | a_i]"}
{"instruction": "Muestra cálculo correlated equilibrium con LP", "response": "Variables: p(a) para cada perfil acción a Restricciones: Σ_{a_{-i}} p(a_i,a_{-i}) [u_i(a_i,a_{-i}) - u_i(a_i',a_{-i})] ≥ 0 ∀i,a_i,a_i' Σ p(a)=1, p(a)≥0 Objetivo: maximizar suma utilities o social welfare"}
{"instruction": "¿Qué es 'algoritmo de Regret Matching'?", "response": "Jugar acciones con probabilidad proporcional a positive regret acumulado. Converge a correlated equilibrium en juegos repetidos."}
{"instruction": "Explica 'problema de la mochila con restricciones de comunicación limitada'", "response": "Agentes pueden comunicarse parcialmente antes de decidir. Cheap talk, signaling equilibria."}
{"instruction": "Define 'Signaling Game'", "response": "Juego con información asimétrica donde sender observa tipo, envía señal; receiver observa señal, toma acción. Separating, pooling, hybrid equilibria."}
{"instruction": "Muestra equilibrio separador signaling game", "response": "Sender con tipo t envía señal s(t) donde s es inyectiva Receiver infiere tipo perfectamente de señal Receiver juega mejor respuesta a tipo inferido Sender no tiene incentivo desviarse"}
{"instruction": "¿Qué es 'algoritmo de Bayesian Persuasion'?", "response": "Sender diseña estructura información (signal) para influenciar receiver. Optimal signal maximiza utilidad sender sujeto a receiver tomando mejor respuesta."}
{"instruction": "Explica 'problema de la mochila con restricciones de verificación costosa'", "response": "Verificar información sobre items es costoso. Optimal inspection policy para equilibrar costo verificación y beneficio información."}
{"instruction": "Define 'Principal-Agent Model'", "response": "Principal diseña contrato para agente con información asimétrica y esfuerzo no observable. Moral hazard, adverse selection."}
{"instruction": "Muestra optimal contract con riesgo neutral principal", "response": "Principal maximiza expected profit sujeto a: 1. Participation constraint: EU_agent ≥ reserva 2. Incentive constraint: agente elige esfuerzo óptimo dado contrato Resolver con first-order approach o revelación directa"}
{"instruction": "¿Qué es 'algoritmo de Screening'?", "response": "Principal ofrece menú de contratos para separar diferentes tipos agente (adverse selection). Self-selection constraints."}
{"instruction": "Explica 'problema de la mochila con restricciones de reputación'", "response": "Decisor construye reputación que afecta interacciones futuras. Reputation models (building, maintaining)."}
{"instruction": "Define 'Repeated Game con reputación'", "response": "Jugador comprometido (commitment type) con probabilidad pequeña. Jugador racional puede imitar comprometido para construir reputación."}
{"instruction": "Muestra equilibrio de reputación en repeated Prisoner's Dilemma", "response": "Con probabilidad ε jugador es tit-for-tat Jugador racional coopera inicialmente para parecer tit-for-tat Si alguna vez deserta, reputación destruida, luego defecto siempre Coopera mientras valor futuro reputación > ganancia corto plazo por desertar"}
{"instruction": "¿Qué es 'algoritmo de Herding Behavior'?", "response": "Modelos donde agentes siguen acciones de otros (informational cascades, social learning). Bayesian updating con señales privadas y observación acciones."}
{"instruction": "Explica 'problema de la mochila con restricciones de conformidad social'", "response": "Utilidad depende de qué items otros seleccionan (bandwagon effect, snob effect). Externalidades sociales."}
{"instruction": "Define 'Information Cascade Model'", "response": "Agentes reciben señales privadas binarias, observan decisiones anteriores. Pueden ignorar su señal y seguir multitud (cascade)."}
{"instruction": "Muestra cascade formation", "response": "Agentes secuencialmente deciden adoptar/rechazar Cada agente observa decisiones anteriores, tiene señal privada Si diferencia número adopciones vs rechazos ≥ 2: cascade comienza, todos siguen mayoría independiente de señal privada"}